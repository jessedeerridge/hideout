<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>テンプレ</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  .player-circle{
    position:relative;width:260px;height:260px;
    margin:20px auto 0;border-radius:50%;
    box-sizing:border-box;border:none;
  }
  .player-circle::before{content:'';}
  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    z-index:360;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  .role-back-mini{
    position:absolute;
    left:50%; top:50%;
    width:22px;height:30px;
    border-radius:6px;border:1px solid #ddd;
    background-image:url('roleura.jpg');
    background-size:cover;background-position:center;
    box-shadow:0 3px 10px rgba(0,0,0,.18);
    pointer-events:none;
    transform: translate(-50%,-50%) translate(var(--rb-x, 0px), var(--rb-y, 0px));
  }

  .ajito-card{
    position:absolute;
    left:50%; top:50%;
    width:34px; height:48px;
    border-radius:9px;
    border:1px solid #ddd;
    background-image:url('ajitoura.jpg');
    background-size:cover; background-position:center;
    box-shadow:0 6px 16px rgba(0,0,0,.22);
    transform: translate(-50%,-50%) translate(var(--ajito-x, 0px), var(--ajito-y, 0px)) rotate(var(--ajito-rot, 0deg));
    transform-origin:center;
    pointer-events:none;
  }
  .ajito-card.mine{ pointer-events:auto; cursor:pointer; }
  .ajito-card.drop-ok{
    border-width:2px;
    box-shadow:0 0 0 3px rgba(0,0,0,.10), 0 6px 16px rgba(0,0,0,.22);
  }

  .ajito-center{
    position:absolute; left:50%; top:50%;
    width:34px; height:48px;
    transform:translate(-50%,-50%);
    border-radius:9px;border:1px solid #ddd;
    background-image:url('ajitoura.jpg');
    background-size:cover; background-position:center;
    box-shadow:0 6px 16px rgba(0,0,0,.22);
    pointer-events:none;
  }
  .ajito-center.hidden{ display:none; }
  .ajito-center.drop-ok{
    border-width:2px;
    box-shadow:0 0 0 3px rgba(0,0,0,.10), 0 6px 16px rgba(0,0,0,.22);
  }

  .chiparea{
    position:absolute;
    left:50%; top:50%;
    width:54px; height:54px;
    border-radius:999px;
    border:2px solid #111;
    background:transparent;
    box-shadow:none;
    pointer-events:none;
    transform: translate(-50%,-50%) translate(var(--chip-x, 0px), var(--chip-y, 0px));
  }
  .chiparea.center{
    transform: translate(-50%,-50%);
  }
  .chiparea.drop-ok{
    border-width:3px;
    box-shadow:0 0 0 3px rgba(0,0,0,.08);
  }

  .colorcard{
    width:22px;height:30px;
    border-radius:7px;
    box-sizing:border-box;
    border:2px solid var(--cc-border, #111);
    background:
      repeating-linear-gradient(
        to bottom,
        var(--cc-dark, #333) 0px,
        var(--cc-dark, #333) 6px,
        var(--cc-light, #999) 6px,
        var(--cc-light, #999) 12px
      );
    box-shadow:0 6px 14px rgba(0,0,0,.22);
    overflow:hidden;
    position:relative;
    flex:0 0 auto;
    transform-origin:center;
  }
  .colorcard::after{
    content:'';
    position:absolute; inset:0;
    background-image:url('c12.jpg');
    background-position:center;
    background-repeat:no-repeat;
    background-size:70% 70%;
    opacity:.95;
    pointer-events:none;
  }

  .tag-color-wrap{
    position:absolute;
    left:0; top:50%;
    transform: translate(-140%, -50%);
    pointer-events:none;
  }
  .tag-color-wrap .colorcard{ pointer-events:none; }
  .player-tag.me .tag-color-wrap{ display:none; }

  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{display:flex;justify-content:center;gap:8px;margin-top:6px;min-height:110px;align-items:center;flex-wrap:wrap;}

  .my-role-card{
    width:80px;height:120px;border-radius:12px;border:1px solid #ddd;background:#fff;
    box-shadow:0 10px 26px rgba(0,0,0,.20);
    background-size:cover;background-position:center;
  }

  .colorcard.my-right{
    width:62px; height:92px;
    border-radius:12px;
    border-width:3px;
  }
  .colorcard.my-right::after{ background-size:78% 78%; }

  /* ===== Attack card ===== */
  .attackcard{
    width:62px;height:92px;border-radius:12px;border:1px solid #ddd;background:#fff;
    box-shadow:0 10px 26px rgba(0,0,0,.20);
    background-size:cover;background-position:center;
    transform-origin:center;
    position:relative;
    flex:0 0 auto;
  }
  .attackcard.draggable{ cursor:grab; touch-action:none; }
  .attackcard.draggable:active{ cursor:grabbing; }

  /* =========================
     ★大小アニメ（控えめ）
     ========================= */
  @keyframes turnPulse {
    0%   { transform:scale(1); }
    50%  { transform:scale(1.08); }
    100% { transform:scale(1); }
  }
  .turn-pulse{ animation: turnPulse 0.92s ease-in-out infinite; }

  .draggable{ cursor:grab; touch-action:none; }
  .draggable:active{ cursor:grabbing; }

  .drag-ghost{
    position:fixed;
    left:0; top:0;
    transform:translate(-50%,-50%);
    z-index:9999;
    pointer-events:none;
    opacity:.92;
    will-change: left, top, transform;
  }

  /* =========================
     ★ chipareaに溜まるミニ色カード
     ========================= */
  .pile-holder{
    position:absolute;
    left:50%; top:50%;
    pointer-events:none;
    transform: translate(-50%,-50%) translate(var(--pile-x, 40px), var(--pile-y, 0px));
  }

  .placed-color{
    position:absolute;
    left:0; top:0;
    width:20px; height:28px;
    border-radius:7px;
    border-width:2px;
    box-shadow:0 6px 14px rgba(0,0,0,.22);
    transform: translate(var(--pc-x, 0px), var(--pc-y, 0px)) rotate(30deg);
    pointer-events:none;
  }
  .placed-color::after{ display:none; }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}

  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
    border-bottom:1px dashed #eee;
  }
  .role-row:last-child{border-bottom:none;}
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    background-size:cover;background-position:center;
  }
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  .peek-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center;
    z-index:320;
  }
  .peek-backdrop.hidden{ display:none; }
  .peek-card{
    width:120px; height:170px;
    border-radius:16px; border:1px solid #ddd;
    background:#fff;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    background-size:cover; background-position:center;
  }

  /* ===== 中央アジト左：Attack Deck（0.8倍） ===== */
  .attack-deck{
    position:absolute;
    left:50%; top:50%;
    width:27px; height:38px;
    border-radius:8px;
    border:1px solid #ddd;
    background-image:url('attackura.jpg');
    background-size:cover;background-position:center;
    box-shadow:0 6px 16px rgba(0,0,0,.22);
    transform:translate(-50%,-50%) translate(-46px, 0px);
    z-index:50;
    pointer-events:none;
  }
  .attack-deck.hidden{ display:none; }
  .deck-count{
    position:absolute; right:-6px; top:-8px;
    min-width:18px; height:18px;
    padding:0 5px;
    border-radius:999px;
    background:#111; color:#fff;
    display:grid; place-items:center;
    font-size:11px; font-weight:800;
    border:1px solid rgba(255,255,255,.65);
    box-shadow:0 6px 14px rgba(0,0,0,.18);
  }

  /* ===== Challenge UI（中央） ===== */
  .challenge-board{
    position:fixed;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    /* ★少しだけ狭く */
    width:min(320px, calc(100% - 24px)); /* ← 340px から少しだけ */
    background:rgba(255,255,255,.96);
    border:1px solid #ddd;
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:330;
    padding:10px 10px 12px;
  }
  .challenge-board.hidden{ display:none; }

  .challenge-head{
    display:flex; align-items:center; justify-content:center;
    margin-bottom:8px;
  }
  .challenge-head > div:first-child{ display:none; }
  .challenge-title, .challenge-sub{ display:none; }

  #challengeNeed{
    font-weight:900;
    font-size:14px;
    opacity:1;
    text-align:center;
  }

  .challenge-zone{
    border:2px dashed #111;
    border-radius:14px;
    min-height:104px;
    /* ★少しタイトに */
    padding:6px;       /* ← 8px → 6px */
    display:flex;
    align-items:center;
    /* ★カードを中央寄せ */
    justify-content:center; /* ← flex-start → center */
    align-content:center;
    gap:8px;           /* ← 10px → 8px */
    flex-wrap:wrap;
    background:transparent;
  }
  .challenge-zone.drop-ok{
    box-shadow:0 0 0 4px rgba(0,0,0,.08);
    border-style:solid;
  }

  .challenge-msg{ display:none; }

  .reveal-row{
    margin-top:10px;
    display:none; /* ★結果はchallengeZone側に統一（2段防止） */
  }

  /* ===== シャッフル：白ボックス透明化してカードだけ残す ===== */
  .challenge-board.stage-shuffle{
    background:transparent;
    border-color:transparent;
    box-shadow:none;
  }
  .challenge-board.stage-shuffle .challenge-head{ display:none; }
  .challenge-board.stage-shuffle .challenge-zone{
    border:none;
    padding:0;
    min-height:auto;
    justify-content:center;
  }
  .challenge-board.stage-shuffle .challenge-zone.drop-ok{
    box-shadow:none;
    border-style:none;
  }

  /* ===== シャッフル：左右中央で混ぜて→再度横に広がる（0.9s） ===== */
  .shuffle-stage{
    position:relative;
    /* ★提出ボックスを狭くしたので、こっちも少しだけ */
    width:min(300px, 92vw); /* ← 320px → 300px */
    height:120px;
  }
  .shuffle-stage .attackcard{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%) translateX(var(--sx,0px)) rotate(var(--rot,0deg));
    animation: shuffleCard 0.90s cubic-bezier(.22,.84,.44,1) forwards;
    will-change: transform;
  }
  @keyframes shuffleCard{
    0%   { transform:translate(-50%,-50%) translateX(var(--sx,0px)) rotate(var(--rot,0deg)); }
    20%  { transform:translate(-50%,-50%) translateX(0px) rotate(0deg); }          /* 集合 */
    35%  { transform:translate(-50%,-50%) translateX(18px) rotate(5deg); }         /* 混ぜ */
    50%  { transform:translate(-50%,-50%) translateX(-18px) rotate(-5deg); }
    65%  { transform:translate(-50%,-50%) translateX(12px) rotate(4deg); }
    75%  { transform:translate(-50%,-50%) translateX(0px) rotate(0deg); }          /* いったん中央 */
    100% { transform:translate(-50%,-50%) translateX(var(--sx,0px)) rotate(var(--rot,0deg)); } /* 再展開 */
  }

  /* ===== 倒れるアニメ：表示後2秒待ってから ===== */
  @keyframes flopBack {
    0% { transform:perspective(600px) rotateX(0deg) translateY(0px); }
    100%{ transform:perspective(600px) rotateX(75deg) translateY(10px); }
  }
  .flop{
    animation: flopBack .55s cubic-bezier(.22,.84,.44,1) forwards;
    animation-delay:2s; /* ★ここ */
    transform-origin:bottom;
  }

  /* ===== 決定ボタン：画面右下 ===== */
  .decide-fixed{
    position:fixed;
    right:16px; bottom:16px;
    width:64px; height:64px;
    border-radius:50%;
    border:1px solid rgba(255,255,255,.9);
    background:#16a34a;
    color:#fff;
    font-weight:900;
    font-size:12px;
    display:grid;
    place-items:center;
    box-shadow:0 12px 28px rgba(0,0,0,.22);
    cursor:pointer;
    user-select:none;
    z-index:380;
  }
  .decide-fixed.redo{ background:#111; }
</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">
      <div id="ajitoCenterChip" class="chiparea center hidden"></div>
      <div id="ajitoCenter" class="ajito-center hidden"></div>
      <div id="attackDeckEl" class="attack-deck hidden">
        <div id="attackDeckCount" class="deck-count">0</div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<div id="challengeBoard" class="challenge-board hidden" aria-label="挑戦">
  <div class="challenge-head">
    <div>
      <div class="challenge-title" id="challengeTitle">挑戦</div>
      <div class="challenge-sub" id="challengeSub">カードを中央へドラッグして選択</div>
    </div>
    <div class="challenge-sub" id="challengeNeed">あと 0 枚選んでください</div>
  </div>
  <div id="challengeZone" class="challenge-zone"></div>
  <div class="challenge-msg" id="challengeMsg"></div>
  <div class="reveal-row" id="revealRow"></div>
</div>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="ajitoPeekBackdrop" class="peek-backdrop hidden">
  <div id="ajitoPeekCard" class="peek-card"></div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で全プレイヤーに<br>
    ・正体カード（1枚）<br>
    ・アジトカード（各1枚＋中央1枚）<br>
    ・Attackデッキ<br>
    を配布します。<br>
    「リセット」で配布情報を消します。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<!-- ★決定ボタン：画面右下（必要枚数出すまで hidden のまま） -->
<button id="decideFixedBtn" class="decide-fixed hidden">決定</button>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove, runTransaction, push
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const IMG = {
  role_swat: 'roleswat.jpg',
  role_tero: 'roletero.jpg',
  role_back: 'roleura.jpg',

  ajito_back: 'ajitoura.jpg',
  ajito_boom: 'ajitoboom.jpg',
  ajito_dummy: 'ajitoshiin.jpg',
  ajito_hideout: 'ajitohideout.jpg',

  attack_back: 'attackura.jpg',
  atk_swat: 'swat.jpg',
  atk_tero: 'terrorist.jpg',
  atk_expert: 'expertswat.jpg',
  atk_super: 'superterrorist.jpg',
};

function attackTypeToImg(type){
  if (type === 'swat') return IMG.atk_swat;
  if (type === 'expertswat') return IMG.atk_expert;
  if (type === 'terrorist') return IMG.atk_tero;
  if (type === 'superterrorist') return IMG.atk_super;
  return IMG.attack_back;
}

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  room: {},
  roles: {},
  ajito: {},
  ajitoCenter: null,

  turn: null,
  placedDrops: {
    player: {},
    center: {}
  },

  attackDeck: null,
  challenge: null,
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');
const ajitoCenterEl = document.getElementById('ajitoCenter');
const ajitoCenterChipEl = document.getElementById('ajitoCenterChip');

const attackDeckEl = document.getElementById('attackDeckEl');
const attackDeckCountEl = document.getElementById('attackDeckCount');

const challengeBoard = document.getElementById('challengeBoard');
const challengeTitle = document.getElementById('challengeTitle');
const challengeSub = document.getElementById('challengeSub');
const challengeNeed = document.getElementById('challengeNeed');
const challengeZone = document.getElementById('challengeZone');
const challengeMsg = document.getElementById('challengeMsg');
const revealRow = document.getElementById('revealRow');

const decideFixedBtn = document.getElementById('decideFixedBtn');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const ajitoPeekBackdrop = document.getElementById('ajitoPeekBackdrop');
const ajitoPeekCard = document.getElementById('ajitoPeekCard');

/* ★ 6色 */
const COLOR6 = [
  { light:'#ef4444', dark:'#7f1d1d' },
  { light:'#f59e0b', dark:'#7c2d12' },
  { light:'#22c55e', dark:'#14532d' },
  { light:'#3b82f6', dark:'#1e3a8a' },
  { light:'#a855f7', dark:'#3b0764' },
  { light:'#06b6d4', dark:'#164e63' },
];
function hashToIndex(str, mod){
  let h = 2166136261;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return Math.abs(h) % mod;
}
function getColorForUserId(uid){
  const idx = hashToIndex(uid || '', COLOR6.length);
  return COLOR6[idx];
}
function makeColorCardEl(uid, extraClass=''){
  const c = getColorForUserId(uid);
  const el = document.createElement('div');
  el.className = `colorcard ${extraClass}`.trim();
  el.style.setProperty('--cc-light', c.light);
  el.style.setProperty('--cc-dark', c.dark);
  el.style.setProperty('--cc-border', c.dark);
  return el;
}

function makeAttackCardEl(cardObj, faceUp=true, extraClass=''){
  const el = document.createElement('div');
  el.className = `attackcard ${extraClass}`.trim();
  el.dataset.cardId = cardObj?.id || '';
  el.dataset.cardType = cardObj?.type || '';
  el.style.backgroundImage = `url('${faceUp ? attackTypeToImg(cardObj.type) : IMG.attack_back}')`;
  return el;
}

function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

/* ====== ヘルプ ====== */
const ROLE_HELP = [
  { key:"swat", name:"スワット", img: IMG.role_swat, text:"市民側（スワット）です。" },
  { key:"tero", name:"テロリスト", img: IMG.role_tero, text:"敵側（テロリスト）です。" },
];
function renderHelpList(){
  helpBody.innerHTML = '';
  ROLE_HELP.forEach((r) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    card.style.backgroundImage = `url('${r.img}')`;

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;
    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

/* ====== アジトプレビュー ====== */
function ajitoTypeToImg(type){
  if (type === 'boom') return IMG.ajito_boom;
  if (type === 'dummy') return IMG.ajito_dummy;
  return IMG.ajito_hideout;
}
function openAjitoPeek(type){
  ajitoPeekCard.style.backgroundImage = `url('${ajitoTypeToImg(type)}')`;
  ajitoPeekBackdrop.classList.remove('hidden');
}
function closeAjitoPeek(){
  ajitoPeekBackdrop.classList.add('hidden');
}
ajitoPeekBackdrop.addEventListener('click', (e) => {
  if (e.target === ajitoPeekBackdrop) closeAjitoPeek();
});

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

/* ====== 手番＆ドラッグ ====== */
function isChallengeActive(){
  return !!(state.challenge && state.challenge.active);
}
function isMyTurn(){
  if (isChallengeActive()) return false;
  return !!(state.turn && state.turn.activePlayerId === state.userId);
}
let dragCtx = null;
let placingLock = false;

function getDropTargets(){
  const targets = [];
  if (isChallengeActive()) return targets;

  if (!ajitoCenterChipEl.classList.contains('hidden')){
    targets.push({ kind:'center', id:'center', el: ajitoCenterChipEl });
  }
  if (!ajitoCenterEl.classList.contains('hidden')){
    targets.push({ kind:'center', id:'center', el: ajitoCenterEl });
  }
  playerCircle.querySelectorAll('.chiparea[data-chip-owner]').forEach(el => {
    targets.push({ kind:'player', id: el.dataset.chipOwner, el });
  });
  playerCircle.querySelectorAll('.ajito-card[data-ajito-owner]').forEach(el => {
    targets.push({ kind:'player', id: el.dataset.ajitoOwner, el });
  });
  return targets;
}

function startColorDrag(e, sourceEl){
  if (!isMyTurn()) return;
  if (placingLock) return;

  const targets = getDropTargets();
  if (!targets.length) return;

  e.preventDefault();

  const r = sourceEl.getBoundingClientRect();
  const ghost = makeColorCardEl(state.userId, 'drag-ghost');
  ghost.style.width = `${Math.max(18, r.width)}px`;
  ghost.style.height = `${Math.max(26, r.height)}px`;

  /* ★左上ワープ防止：append前に座標セット（掴んだ位置＝中央） */
  ghost.style.left = `${e.clientX}px`;
  ghost.style.top  = `${e.clientY}px`;

  document.body.appendChild(ghost);

  sourceEl.style.visibility = 'hidden';

  dragCtx = { sourceEl, ghost, targets, hover: null, pointerId: e.pointerId, kind:'color' };

  const clearHighlights = () => {
    dragCtx?.targets.forEach(t => t.el.classList.remove('drop-ok'));
  };

  const onMove = (ev) => {
    if (!dragCtx) return;
    moveGhost(ev);

    let found = null;
    for (const t of dragCtx.targets){
      const rect = t.el.getBoundingClientRect();
      if (pointInRect(ev.clientX, ev.clientY, rect)){
        found = t;
        break;
      }
    }
    clearHighlights();
    if (found) found.el.classList.add('drop-ok');
    dragCtx.hover = found;
  };

  const onUp = async () => {
    if (!dragCtx) return;
    window.removeEventListener('pointermove', onMove);

    const hover = dragCtx.hover;

    clearHighlights();
    dragCtx.ghost.remove();
    dragCtx.sourceEl.style.visibility = '';
    dragCtx = null;

    if (hover){
      await placeDropAndAdvanceTurn(hover.kind, hover.id);
    }
  };

  window.addEventListener('pointermove', onMove, { passive:false });
  window.addEventListener('pointerup', onUp, { once:true, passive:false });
}
function moveGhost(e){
  if (!dragCtx) return;
  dragCtx.ghost.style.left = `${e.clientX}px`;
  dragCtx.ghost.style.top  = `${e.clientY}px`;
}
function pointInRect(x, y, rect){
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}

async function placeDropAndAdvanceTurn(kind, targetId){
  if (!state.roomCode) return;
  if (!isMyTurn()) return;
  if (placingLock) return;
  if (isChallengeActive()) return;

  placingLock = true;
  try{
    const base = `rooms/${state.roomCode}`;
    const targetRef =
      (kind === 'center')
        ? ref(db, `${base}/placedDrops/center`)
        : ref(db, `${base}/placedDrops/player/${targetId}`);

    await push(targetRef, { from: state.userId, at: Date.now() });

    const ids = (latestPlayers || []).map(p => p.id);
    if (!ids.length) return;

    const nextId = (() => {
      const i = ids.indexOf(state.userId);
      if (i === -1) return ids[0];
      return ids[(i + 1) % ids.length];
    })();

    await runTransaction(
      ref(db, `${base}/turn`),
      (cur) => {
        if (!cur || cur.activePlayerId !== state.userId) return cur;
        return {
          ...cur,
          activePlayerId: nextId,
          turnNo: (cur.turnNo || 0) + 1,
          updatedAt: Date.now()
        };
      }
    );
  } finally {
    placingLock = false;
  }
}
function markDraggable(el){
  el.classList.add('draggable');
  el.style.pointerEvents = 'auto';
  el.addEventListener('pointerdown', (e) => startColorDrag(e, el));
}

/* ====== Attack deck build ====== */
function buildAttackDeck(n){
  const deck = [];
  const pushN = (type, count) => { for(let i=0;i<count;i++) deck.push(type); };

  if (n === 4){
    pushN('swat', 8); pushN('expertswat', 4);
    pushN('terrorist', 4); pushN('superterrorist', 4);
  } else if (n === 5){
    pushN('swat', 10); pushN('expertswat', 5);
    pushN('terrorist', 5); pushN('superterrorist', 5);
  } else if (n === 6){
    pushN('swat', 12); pushN('expertswat', 6);
    pushN('terrorist', 6); pushN('superterrorist', 6);
  } else {
    const sw = Math.max(8, n*2);
    const ex = Math.max(4, Math.ceil(n));
    const te = Math.max(4, Math.ceil(n));
    const su = Math.max(4, Math.ceil(n));
    pushN('swat', sw); pushN('expertswat', ex);
    pushN('terrorist', te); pushN('superterrorist', su);
  }
  return shuffle(deck);
}

/* ====== 挑戦ロジック ====== */
function getChallengeMyNeed(ch){
  const me = ch?.participants?.[state.userId];
  return me?.need || 0;
}
function getChallengeMyDealt(ch){
  const me = ch?.participants?.[state.userId];
  return Array.isArray(me?.dealt) ? me.dealt : [];
}
function getChallengeMyChosen(ch){
  const me = ch?.participants?.[state.userId];
  return Array.isArray(me?.chosen) ? me.chosen : [];
}
function isChallengeMyDecided(ch){
  const me = ch?.participants?.[state.userId];
  return !!me?.decided;
}

function scoreAttackType(t){
  if (t === 'swat') return 0;
  if (t === 'expertswat') return 1;
  if (t === 'terrorist') return -1;
  if (t === 'superterrorist') return -2;
  return 0;
}

/* ====== Attackドラッグ ====== */
let attackDrag = null;

function startAttackDrag(e, sourceEl, from){
  if (!state.roomCode) return;
  const ch = state.challenge;
  if (!ch?.active) return;
  if (ch.stage !== 'select') return;

  const myNeed = getChallengeMyNeed(ch);
  if (myNeed <= 0) return;

  if (isChallengeMyDecided(ch)) return;

  e.preventDefault();

  const rect = sourceEl.getBoundingClientRect();
  const ghost = sourceEl.cloneNode(true);
  ghost.classList.add('drag-ghost');
  ghost.style.width = rect.width + 'px';
  ghost.style.height = rect.height + 'px';
  ghost.style.pointerEvents = 'none';

  /* ★左上ワープ防止：append前に座標セット（掴んだ位置＝中央） */
  ghost.style.left = `${e.clientX}px`;
  ghost.style.top  = `${e.clientY}px`;

  document.body.appendChild(ghost);

  sourceEl.style.visibility = 'hidden';

  attackDrag = {
    from, sourceEl, ghost,
    cardId: sourceEl.dataset.cardId,
    hoverZone: false,
    pointerId: e.pointerId,
  };

  const clearZone = () => challengeZone.classList.remove('drop-ok');

  const onMove = (ev) => {
    if (!attackDrag) return;
    ghost.style.left = `${ev.clientX}px`;
    ghost.style.top  = `${ev.clientY}px`;

    const z = challengeZone.getBoundingClientRect();
    const inside = pointInRect(ev.clientX, ev.clientY, z);
    clearZone();
    if (inside) challengeZone.classList.add('drop-ok');
    attackDrag.hoverZone = inside;
  };

  const onUp = async (ev) => {
    window.removeEventListener('pointermove', onMove);
    clearZone();

    if (!attackDrag) return;
    const { from, cardId } = attackDrag;

    attackDrag.ghost.remove();
    attackDrag.sourceEl.style.visibility = '';
    const hoverZone = attackDrag.hoverZone;
    attackDrag = null;

    if (!cardId) return;

    if (from === 'hand'){
      if (hoverZone){
        await chooseAttackCard(cardId);
      }
    } else if (from === 'chosen'){
      const boardRect = challengeBoard.getBoundingClientRect();
      const isDown = ev.clientY > (boardRect.top + boardRect.height + 30);
      if (isDown){
        await unchooseAttackCard(cardId);
      }
    }
  };

  window.addEventListener('pointermove', onMove, { passive:false });
  window.addEventListener('pointerup', onUp, { once:true, passive:false });
}

async function chooseAttackCard(cardId){
  const ch = state.challenge;
  if (!ch?.active) return;
  if (ch.stage !== 'select') return;

  const myNeed = getChallengeMyNeed(ch);
  if (myNeed <= 0) return;

  const dealt = getChallengeMyDealt(ch);
  const chosen = getChallengeMyChosen(ch);

  const has = dealt.some(c => c.id === cardId);
  if (!has) return;

  let next = chosen.slice();

  if (next.includes(cardId)) return;

  if (next.length < myNeed){
    next.push(cardId);
  } else {
    next[myNeed - 1] = cardId;
  }

  await update(ref(db, `rooms/${state.roomCode}/challenge/participants/${state.userId}`), {
    chosen: next
  });
}

async function unchooseAttackCard(cardId){
  const ch = state.challenge;
  if (!ch?.active) return;
  if (ch.stage !== 'select') return;

  const chosen = getChallengeMyChosen(ch);
  const next = chosen.filter(id => id !== cardId);

  await update(ref(db, `rooms/${state.roomCode}/challenge/participants/${state.userId}`), {
    chosen: next,
    decided: false
  });
}

async function setMyDecided(nextDecided){
  if (!state.roomCode) return;
  const ch = state.challenge;
  if (!ch?.active) return;
  if (ch.stage !== 'select') return;

  await update(ref(db, `rooms/${state.roomCode}/challenge/participants/${state.userId}`), {
    decided: !!nextDecided
  });
}

/* ★決定ボタン（右下固定）のクリック */
decideFixedBtn.addEventListener('click', async () => {
  const ch = state.challenge;
  if (!ch?.active || ch.stage !== 'select') return;
  const myNeed = getChallengeMyNeed(ch);
  const myChosenLen = getChallengeMyChosen(ch).length;
  if (myNeed <= 0 || myChosenLen !== myNeed) return; /* ★必要枚数出すまでは何もしない */
  const myDecided = isChallengeMyDecided(ch);
  await setMyDecided(!myDecided);
});

/* ====== 挑戦UI描画 ====== */
let lastMyDealtKey = '';
function renderChallengeUI(){
  const ch = state.challenge;

  const deckCount = state.attackDeck?.draw?.length ?? 0;
  const showDeck = !!(state.ajitoCenter && state.attackDeck && Array.isArray(state.attackDeck.draw));
  attackDeckEl.classList.toggle('hidden', !showDeck);
  if (showDeck) attackDeckCountEl.textContent = String(deckCount);

  /* ★決定ボタンはまず隠す（必要枚数を出し切った時だけ出す） */
  decideFixedBtn.classList.add('hidden');
  decideFixedBtn.classList.remove('redo');

  if (!ch?.active){
    challengeBoard.classList.add('hidden');
    challengeBoard.classList.remove('stage-shuffle');
    challengeZone.innerHTML = '';
    revealRow.innerHTML = '';
    challengeMsg.textContent = '';
    lastMyDealtKey = '';
    return;
  }

  challengeBoard.classList.remove('hidden');

  const myNeed = getChallengeMyNeed(ch);
  const myDealt = getChallengeMyDealt(ch);
  const myChosen = getChallengeMyChosen(ch);
  const myDecided = isChallengeMyDecided(ch);

  /* ★提出白ボックス透明：シャッフル中だけ */
  challengeBoard.classList.toggle('stage-shuffle', ch.stage === 'shuffle');

  if (ch.stage === 'select'){
    const needLeft = Math.max(0, myNeed - myChosen.length);
    challengeNeed.textContent = (needLeft === 0) ? '決定してください' : `あと ${needLeft} 枚選んでください`;
  } else if (ch.stage === 'shuffle'){
    challengeNeed.textContent = 'シャッフル中…';
  } else if (ch.stage === 'reveal'){
    const success = !!ch.result?.success;
    challengeNeed.textContent = success ? '成功' : '失敗';
  } else {
    challengeNeed.textContent = '';
  }

  challengeZone.innerHTML = '';
  revealRow.innerHTML = '';

  if (ch.stage === 'shuffle'){
    const stage = document.createElement('div');
    stage.className = 'shuffle-stage';

    const offsets = [-96, -32, 32, 96];
    const rots    = [-10, -4, 4, 10];

    for (let i=0;i<4;i++){
      const b = makeAttackCardEl({id:'', type:'swat'}, false, '');
      b.style.setProperty('--sx', offsets[i] + 'px');
      b.style.setProperty('--rot', rots[i] + 'deg');
      stage.appendChild(b);
    }
    challengeZone.appendChild(stage);

  } else if (ch.stage === 'reveal'){
    const types = Array.isArray(ch.revealed) ? ch.revealed : [];
    const success = !!ch.result?.success;

    types.forEach((t) => {
      const c = makeAttackCardEl({id:'', type:t}, true, '');
      const isTero = (t === 'terrorist' || t === 'superterrorist');
      const isSwat = (t === 'swat' || t === 'expertswat');

      if ((success && isTero) || (!success && isSwat)){
        c.classList.add('flop');
      }
      challengeZone.appendChild(c);
    });

  } else {
    const all = buildCentralChosenList(ch, true);
    all.forEach(cardView => challengeZone.appendChild(cardView.el));
  }

  /* ★決定ボタン：必要枚数のAttackカードを出し切った時だけ出現 */
  if (ch.stage === 'select' && myNeed > 0 && myChosen.length === myNeed){
    decideFixedBtn.classList.remove('hidden');
    decideFixedBtn.textContent = myDecided ? 'やり直す' : '決定';
    if (myDecided) decideFixedBtn.classList.add('redo');
  }

  renderMyRole();

  if (ch.stage === 'select' && myDealt.length){
    const key = myDealt.map(c => c.id).join(',');
    if (key && key !== lastMyDealtKey){
      lastMyDealtKey = key;
      playDealAnimationForMe(myDealt);
    }
  }
}

function buildCentralChosenList(ch, faceUpForMe){
  const parts = ch.participants || {};
  const meId = state.userId;

  const others = [];
  const mine = [];

  for (const [uid, info] of Object.entries(parts)){
    const dealt = Array.isArray(info.dealt) ? info.dealt : [];
    const chosenIds = Array.isArray(info.chosen) ? info.chosen : [];
    const chosenObjs = chosenIds
      .map(id => dealt.find(c => c.id === id))
      .filter(Boolean);

    if (uid === meId){
      chosenObjs.forEach((c) => {
        const el = makeAttackCardEl(c, !!faceUpForMe, '');
        if (ch.stage === 'select' && !isChallengeMyDecided(ch)){
          el.classList.add('draggable');
          el.addEventListener('pointerdown', (e) => startAttackDrag(e, el, 'chosen'));
          el.classList.add('turn-pulse');
        }
        mine.push({uid, el, type:c.type});
      });
    } else {
      chosenObjs.forEach((c) => {
        const el = makeAttackCardEl(c, false, '');
        others.push({uid, el, type:c.type});
      });
    }
  }
  return [...others, ...mine];
}

function playDealAnimationForMe(myDealt){
  if (attackDeckEl.classList.contains('hidden')) return;

  const deckRect = attackDeckEl.getBoundingClientRect();
  const handRect = myHandEl.getBoundingClientRect();

  const flyN = Math.min(6, myDealt.length);
  for (let i=0;i<flyN;i++){
    const el = document.createElement('div');
    el.className = 'attackcard drag-ghost';
    el.style.backgroundImage = `url('${IMG.attack_back}')`;
    el.style.width = '62px';
    el.style.height = '92px';
    el.style.left = (deckRect.left + deckRect.width/2) + 'px';
    el.style.top  = (deckRect.top + deckRect.height/2) + 'px';
    el.style.opacity = '0.95';
    el.style.transition = 'transform .50s cubic-bezier(.22,.84,.44,1), opacity .50s';
    document.body.appendChild(el);

    const tx = (handRect.left + handRect.width/2) - (deckRect.left + deckRect.width/2) + (i*8);
    const ty = (handRect.top + handRect.height/2) - (deckRect.top + deckRect.height/2);

    requestAnimationFrame(() => {
      el.style.transform = `translate(-50%,-50%) translate(${tx}px, ${ty}px) rotate(${(i-2)*4}deg) scale(1.01)`;
      el.style.opacity = '0.18';
    });
    setTimeout(() => el.remove(), 620);
  }
}

/* ====== ホスト：挑戦開始判定 ====== */
let startingChallengeLock = false;

function getTop4FromObj(obj){
  const entries = Object.entries(obj || {})
    .map(([k,v]) => ({ key:k, ...(v||{}) }))
    .filter(x => x && x.from)
    .sort((a,b) => (a.at||0) - (b.at||0));
  return entries.slice(0,4);
}

function pickChallengeCandidate(){
  const candidates = [];

  if (state.placedDrops?.center){
    const all = Object.entries(state.placedDrops.center || {})
      .map(([k,v]) => ({ key:k, ...(v||{}) }))
      .filter(x => x && x.from)
      .sort((a,b) => (a.at||0)-(b.at||0));
    if (all.length >= 4){
      candidates.push({
        kind:'center',
        id:'center',
        fourthAt: all[3].at || 0
      });
    }
  }

  const pMap = state.placedDrops?.player || {};
  for (const [pid, obj] of Object.entries(pMap)){
    const all = Object.entries(obj || {})
      .map(([k,v]) => ({ key:k, ...(v||{}) }))
      .filter(x => x && x.from)
      .sort((a,b) => (a.at||0)-(b.at||0));
    if (all.length >= 4){
      candidates.push({
        kind:'player',
        id: pid,
        fourthAt: all[3].at || 0
      });
    }
  }

  if (!candidates.length) return null;
  candidates.sort((a,b) => (a.fourthAt||0) - (b.fourthAt||0));
  return candidates[0];
}

async function hostStartChallengeIfNeeded(){
  if (!state.isHost) return;
  if (!state.roomCode) return;
  if (startingChallengeLock) return;
  if (state.challenge?.active) return;

  const cand = pickChallengeCandidate();
  if (!cand) return;

  startingChallengeLock = true;
  try{
    await startChallenge(cand.kind, cand.id);
  } finally {
    startingChallengeLock = false;
  }
}

async function startChallenge(kind, id){
  const base = `rooms/${state.roomCode}`;
  const snap = await get(ref(db, `${base}/placedDrops`));
  const placed = snap.val() || {};
  const targetObj =
    (kind === 'center')
      ? (placed.center || {})
      : ((placed.player || {})[id] || {});

  const top4 = getTop4FromObj(targetObj);
  if (top4.length < 4) return;

  const needMap = {};
  top4.forEach(d => {
    needMap[d.from] = (needMap[d.from] || 0) + 1;
  });

  const deckSnap = await get(ref(db, `${base}/attackDeck`));
  let deck = deckSnap.val();
  if (!deck || !Array.isArray(deck.draw)){
    const n = latestPlayers.length || 4;
    deck = { draw: buildAttackDeck(n), discard: [] };
  }
  deck.draw = Array.isArray(deck.draw) ? deck.draw.slice() : [];
  deck.discard = Array.isArray(deck.discard) ? deck.discard.slice() : [];

  const ensureDraw = (needN) => {
    if (deck.draw.length >= needN) return;
    if (deck.discard.length){
      deck.draw = shuffle(deck.draw.concat(shuffle(deck.discard.slice())));
      deck.discard = [];
    }
  };

  const participants = {};
  for (const [uid, need] of Object.entries(needMap)){
    if (!need) continue;
    const dealCount = need * 2;
    ensureDraw(dealCount);

    const dealt = [];
    for (let i=0;i<dealCount;i++){
      if (!deck.draw.length){
        ensureDraw(1);
      }
      const type = deck.draw.pop();
      dealt.push({ id: crypto.randomUUID(), type });
    }
    participants[uid] = {
      need,
      dealt,
      chosen: [],
      decided: false
    };
  }

  const challenge = {
    active: true,
    stage: 'select',
    target: { kind, id },
    dropKeys: top4.map(d => d.key),
    startedAt: Date.now(),
    participants
  };

  await update(ref(db, base), {
    attackDeck: deck,
    challenge: challenge
  });
}

let hostShuffleTimer = null;
let hostRevealTimer = null;
let hostFinishTimer = null;

function clearHostTimers(){
  if (hostShuffleTimer) clearTimeout(hostShuffleTimer);
  if (hostRevealTimer) clearTimeout(hostRevealTimer);
  if (hostFinishTimer) clearTimeout(hostFinishTimer);
  hostShuffleTimer = hostRevealTimer = hostFinishTimer = null;
}

async function hostProgressChallenge(){
  if (!state.isHost) return;
  const ch = state.challenge;
  if (!ch?.active) { clearHostTimers(); return; }

  if (ch.stage === 'select'){
    const parts = ch.participants || {};
    const uids = Object.keys(parts);
    if (!uids.length) return;

    const allDone = uids.every(uid => {
      const p = parts[uid] || {};
      const need = p.need || 0;
      const chosen = Array.isArray(p.chosen) ? p.chosen : [];
      return need > 0 && chosen.length === need && !!p.decided;
    });

    if (!allDone) return;
    if (hostShuffleTimer || hostRevealTimer || hostFinishTimer) return;

    await update(ref(db, `rooms/${state.roomCode}/challenge`), {
      stage: 'shuffle',
      shuffleAt: Date.now()
    });

    hostRevealTimer = setTimeout(async () => {
      const freshSnap = await get(ref(db, `rooms/${state.roomCode}/challenge`));
      const c2 = freshSnap.val();
      if (!c2?.active) return;

      const pool = [];
      for (const [uid, p] of Object.entries(c2.participants || {})){
        const dealt = Array.isArray(p.dealt) ? p.dealt : [];
        const chosenIds = Array.isArray(p.chosen) ? p.chosen : [];
        chosenIds.forEach(id => {
          const obj = dealt.find(x => x.id === id);
          if (obj) pool.push({ uid, ...obj });
        });
      }
      const picked = pool.slice(0,4);
      const types = picked.map(x => x.type);
      shuffle(types);

      const total = types.reduce((s,t) => s + scoreAttackType(t), 0);
      const success = total >= 0;

      await update(ref(db, `rooms/${state.roomCode}/challenge`), {
        stage: 'reveal',
        revealed: types,
        result: { total, success },
        revealedAt: Date.now()
      });

      hostFinishTimer = setTimeout(async () => {
        await hostFinishChallenge();
      }, 3300);
    }, 900);
  }
}

async function hostFinishChallenge(){
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  const snap = await get(ref(db, `${base}`));
  const room = snap.val() || {};
  const ch = room.challenge;
  if (!ch?.active) return;

  let deck = room.attackDeck;
  if (!deck || !Array.isArray(deck.draw)){
    const n = latestPlayers.length || 4;
    deck = { draw: buildAttackDeck(n), discard: [] };
  }
  deck.draw = Array.isArray(deck.draw) ? deck.draw.slice() : [];
  deck.discard = Array.isArray(deck.discard) ? deck.discard.slice() : [];

  const revealed = Array.isArray(ch.revealed) ? ch.revealed : [];
  const allSwat = revealed.length === 4 && revealed.every(t => t === 'swat');

  const chosenTypes = [];
  const unusedTypes = [];

  for (const [uid, p] of Object.entries(ch.participants || {})){
    const dealt = Array.isArray(p.dealt) ? p.dealt : [];
    const chosenIds = Array.isArray(p.chosen) ? p.chosen : [];
    const chosenSet = new Set(chosenIds);

    dealt.forEach(c => {
      if (chosenSet.has(c.id)) chosenTypes.push(c.type);
      else unusedTypes.push(c.type);
    });
  }

  deck.draw = deck.draw.concat(unusedTypes);

  if (allSwat){
    deck.draw = deck.draw.concat(chosenTypes);
  } else {
    deck.discard = deck.discard.concat(chosenTypes);
  }

  deck.draw = shuffle(deck.draw);

  const target = ch.target || {};
  const kind = target.kind;
  const tid = target.id;
  const dropKeys = Array.isArray(ch.dropKeys) ? ch.dropKeys : [];

  const updates = {
    attackDeck: deck,
    challenge: null
  };

  dropKeys.forEach((k) => {
    if (kind === 'center'){
      updates[`placedDrops/center/${k}`] = null;
    } else {
      updates[`placedDrops/player/${tid}/${k}`] = null;
    }
  });

  await update(ref(db, base), updates);

  clearHostTimers();
}

/* ====== 購読 ====== */
function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
  });
}
function subscribeRoles(){
  const rolesRef = ref(db, `rooms/${state.roomCode}/roles`);
  onValue(rolesRef, snap => {
    state.roles = snap.val() || {};
    renderMyRole();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}
function subscribeAjito(){
  const ajRef = ref(db, `rooms/${state.roomCode}/ajito`);
  const centerRef = ref(db, `rooms/${state.roomCode}/ajitoCenter`);

  onValue(ajRef, snap => {
    state.ajito = snap.val() || {};
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
  onValue(centerRef, snap => {
    state.ajitoCenter = snap.val() || null;
    const hasCenter = !!state.ajitoCenter;
    ajitoCenterEl.classList.toggle('hidden', !hasCenter);
    ajitoCenterChipEl.classList.toggle('hidden', !hasCenter);
  });
}
function subscribeTurnAndPlaced(){
  const tRef = ref(db, `rooms/${state.roomCode}/turn`);
  const pRef = ref(db, `rooms/${state.roomCode}/placedDrops`);

  onValue(tRef, snap => {
    state.turn = snap.val() || null;
    renderMyRole();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
  onValue(pRef, snap => {
    const v = snap.val() || {};
    state.placedDrops = {
      player: v.player || {},
      center: v.center || {}
    };
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);

    hostStartChallengeIfNeeded();
  });
}
function subscribeAttackDeck(){
  const aRef = ref(db, `rooms/${state.roomCode}/attackDeck`);
  onValue(aRef, snap => {
    state.attackDeck = snap.val() || null;
    renderChallengeUI();
  });
}
function subscribeChallenge(){
  const cRef = ref(db, `rooms/${state.roomCode}/challenge`);
  onValue(cRef, snap => {
    state.challenge = snap.val() || null;

    renderMyRole();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
    renderChallengeUI();

    hostProgressChallenge();
  });
}

/* ====== 表示 ====== */
function roleTypeToImg(type){
  return (type === 'tero') ? IMG.role_tero : IMG.role_swat;
}
function renderMyRole(){
  myHandEl.innerHTML = '';
  const my = state.roles[state.userId];
  if (!my || !my.type) return;

  const card = document.createElement('div');
  card.className = 'my-role-card';
  card.style.backgroundImage = `url('${roleTypeToImg(my.type)}')`;
  myHandEl.appendChild(card);

  const myColor = makeColorCardEl(state.userId, 'my-right');
  if (isMyTurn()){
    myColor.classList.add('turn-pulse');
    markDraggable(myColor);
  }
  myHandEl.appendChild(myColor);

  const ch = state.challenge;
  if (ch?.active && ch.stage === 'select'){
    const myNeed = getChallengeMyNeed(ch);
    if (myNeed > 0){
      const dealt = getChallengeMyDealt(ch);
      const chosenIds = new Set(getChallengeMyChosen(ch));
      const decided = isChallengeMyDecided(ch);

      dealt
        .filter(c => !chosenIds.has(c.id))
        .forEach((c) => {
          const a = makeAttackCardEl(c, true, '');
          if (!decided){
            a.classList.add('turn-pulse');
            a.classList.add('draggable');
            a.addEventListener('pointerdown', (e) => startAttackDrag(e, a, 'hand'));
          }
          myHandEl.appendChild(a);
        });
    }
  }
}

/* ====== 入室 ====== */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeRoles();
  subscribeAjito();
  subscribeTurnAndPlaced();
  subscribeAttackDeck();
  subscribeChallenge();

  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

/* ====== 着席 ====== */
async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;
  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);
  });
}

/* =========================
   ★chiparea基準の「溜まり山」
   ========================= */
function ensurePileHolder(parentEl, className){
  let h = parentEl.querySelector(`.${className}`);
  if (!h){
    h = document.createElement('div');
    h.className = `pile-holder ${className}`;
    parentEl.appendChild(h);
  } else {
    h.innerHTML = '';
  }
  h.style.setProperty('--pile-x', '22px');
  h.style.setProperty('--pile-y', '-28px');
  return h;
}

function renderDropsIntoHolder(holder, drops){
  const GAP_Y = 12;
  const FIX_X = 0;

  drops.forEach((d, i) => {
    const fromId = d.from;
    if (!fromId) return;
    const pc = makeColorCardEl(fromId, 'placed-color');
    pc.style.setProperty('--pc-x', `${FIX_X}px`);
    pc.style.setProperty('--pc-y', `${i * GAP_Y}px`);
    holder.appendChild(pc);
  });
}

function renderPlayerCircle(players){
  playerCircle.querySelectorAll('.player-tag, .center-placed, .pile-holder.center-pile').forEach(el => el.remove());
  if (!players.length) return;

  ajitoCenterEl.classList.toggle('hidden', !state.ajitoCenter);
  ajitoCenterChipEl.classList.toggle('hidden', !state.ajitoCenter);

  const showDeck = !!(state.ajitoCenter && state.attackDeck && Array.isArray(state.attackDeck.draw));
  attackDeckEl.classList.toggle('hidden', !showDeck);
  if (showDeck){
    attackDeckCountEl.textContent = String(state.attackDeck.draw.length || 0);
  }

  const n = players.length;
  const radius = 45;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  const activeId = isChallengeActive() ? null : (state.turn?.activePlayerId || null);

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top = `${y}%`;

    if (p.id !== state.userId){
      const wrap = document.createElement('div');
      wrap.className = 'tag-color-wrap';

      const mini = makeColorCardEl(p.id, '');
      if (activeId && p.id === activeId){
        mini.classList.add('turn-pulse');
      }
      wrap.appendChild(mini);
      tag.appendChild(wrap);
    }

    tag.onclick = () => {
      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    const ox = Math.cos(angle);
    const oy = Math.sin(angle);
    const ix = -ox;
    const iy = -oy;

    if (p.id !== state.userId && state.roles[p.id]?.type){
      const miniBack = document.createElement('div');
      miniBack.className = 'role-back-mini';
      const distOuter = 35;
      miniBack.style.setProperty('--rb-x', `${ox * distOuter}px`);
      miniBack.style.setProperty('--rb-y', `${oy * distOuter}px`);
      tag.appendChild(miniBack);
    }

    if (state.ajito[p.id]?.type){
      const chip = document.createElement('div');
      chip.className = 'chiparea';
      chip.dataset.chipOwner = p.id;

      const distAj = 40;
      const tx = ix * distAj;
      const ty = iy * distAj;

      chip.style.setProperty('--chip-x', `${tx}px`);
      chip.style.setProperty('--chip-y', `${ty}px`);
      tag.appendChild(chip);

      const aj = document.createElement('div');
      aj.className = 'ajito-card' + (p.id === state.userId ? ' mine' : '');
      aj.dataset.ajitoOwner = p.id;

      const angleDeg = angle * 180 / Math.PI;
      const rotDeg = angleDeg + 270;

      aj.style.setProperty('--ajito-x', `${tx}px`);
      aj.style.setProperty('--ajito-y', `${ty}px`);
      aj.style.setProperty('--ajito-rot', `${rotDeg}deg`);

      if (p.id === state.userId){
        aj.addEventListener('click', (e) => {
          e.stopPropagation();
          const myAj = state.ajito[state.userId];
          if (!myAj?.type) return;
          openAjitoPeek(myAj.type);
        });
      }
      tag.appendChild(aj);

      const obj = state.placedDrops?.player?.[p.id] || {};
      const drops = Object.values(obj)
        .filter(Boolean)
        .sort((a,b) => (a.at||0) - (b.at||0));

      if (drops.length){
        const holder = ensurePileHolder(tag, 'player-pile');
        holder.style.transform =
          `translate(-50%,-50%) translate(${tx}px, ${ty}px) translate(var(--pile-x,22px), var(--pile-y,-10px))`;
        renderDropsIntoHolder(holder, drops);
      }
    }

    playerCircle.appendChild(tag);
  });

  const centerObj = state.placedDrops?.center || {};
  const centerDrops = Object.values(centerObj)
    .filter(Boolean)
    .sort((a,b) => (a.at||0) - (b.at||0));

  if (centerDrops.length && state.ajitoCenter){
    const holder = document.createElement('div');
    holder.className = 'pile-holder center-pile center-placed';
    holder.style.setProperty('--pile-x', '22px');
    holder.style.setProperty('--pile-y', '-28px');
    playerCircle.appendChild(holder);
    renderDropsIntoHolder(holder, centerDrops);
  }
}

/* ====== 追い出し ====== */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* ====== 配布 ====== */
function getTeroCount(n){
  if (n <= 3) return 0;
  if (n === 4) return (Math.random() < 0.5) ? 1 : 2;
  if (n === 5) return 2;
  if (n === 6) return (Math.random() < 0.5) ? 2 : 3;
  return Math.max(0, Math.floor(n/3));
}
function buildAjitoDeck(n){
  const deck = [];
  const pushN = (type, count) => { for(let i=0;i<count;i++) deck.push(type); };

  if (n === 1){
    pushN('hideout', 2);
  } else if (n === 2){
    pushN('hideout', 2); pushN('boom', 1);
  } else if (n === 3){
    pushN('hideout', 2); pushN('boom', 1); pushN('dummy', 1);
  } else if (n === 4){
    pushN('hideout', 2); pushN('dummy', 2); pushN('boom', 1);
  } else if (n === 5){
    pushN('hideout', 2); pushN('dummy', 3); pushN('boom', 1);
  } else if (n === 6){
    pushN('hideout', 3); pushN('dummy', 3); pushN('boom', 1);
  } else {
    pushN('hideout', Math.max(2, Math.ceil((n+1)/2)));
    pushN('dummy', Math.max(0, (n+1) - deck.length - 1));
    pushN('boom', 1);
  }
  return deck;
}

async function dealRolesAndAjito(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const players = Object.values(tables)
    .filter(t => t && t.playerId)
    .map(t => ({ id: t.playerId, name: t.playerName || '名無し' }));

  const n = players.length;
  if (n <= 0) return;

  const teroCount = getTeroCount(n);
  const rolesArr = [];
  for (let i=0;i<teroCount;i++) rolesArr.push('tero');
  for (let i=0;i<n-teroCount;i++) rolesArr.push('swat');
  shuffle(rolesArr);

  const rolesObj = {};
  players.forEach((p, i) => {
    rolesObj[p.id] = { type: rolesArr[i] };
  });

  const deck = buildAjitoDeck(n);
  shuffle(deck);

  const center = deck.pop();
  const ajObj = {};
  players.forEach((p) => {
    ajObj[p.id] = { type: deck.pop() };
  });

  const startPlayerId = players[Math.floor(Math.random() * players.length)].id;

  const attack = {
    draw: buildAttackDeck(n),
    discard: []
  };

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    set(ref(db, `${base}/roles`), rolesObj),
    set(ref(db, `${base}/ajito`), ajObj),
    set(ref(db, `${base}/ajitoCenter`), { type: center }),
    set(ref(db, `${base}/attackDeck`), attack),
    update(ref(db, `${base}`), { gameStartedAt: Date.now() }),
    remove(ref(db, `${base}/placedDrops`)),
    remove(ref(db, `${base}/challenge`)),
    set(ref(db, `${base}/turn`), {
      activePlayerId: startPlayerId,
      turnNo: 1,
      startedAt: Date.now()
    }),
  ]);
}

/* ====== ホスト設定ポップ ====== */
hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});
btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await dealRolesAndAjito();
  startPop.classList.add('hidden');
});

/* ====== リセット ====== */
btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;

  await Promise.all([
    remove(ref(db, `${base}/roles`)),
    remove(ref(db, `${base}/ajito`)),
    remove(ref(db, `${base}/ajitoCenter`)),
    remove(ref(db, `${base}/attackDeck`)),
    remove(ref(db, `${base}/challenge`)),
    remove(ref(db, `${base}/gameStartedAt`)),
    remove(ref(db, `${base}/turn`)),
    remove(ref(db, `${base}/placedDrops`)),
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
  ]);

  state.seatedTable = null;

  startPop.classList.add('hidden');
  await syncSeatUI();
});
</script>

</body>
</html>

