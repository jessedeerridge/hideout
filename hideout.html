<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>テンプレ</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  .player-circle{
    position:relative;width:260px;height:260px;
    margin:20px auto 0;border-radius:50%;
    box-sizing:border-box;border:none;
  }
  .player-circle::before{content:'';}
  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    z-index:360;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  .role-back-mini{
    position:absolute;
    left:50%; top:50%;
    width:22px;height:30px;
    border-radius:6px;border:1px solid #ddd;
    background-image:url('roleura.jpg');
    background-size:cover;background-position:center;
    box-shadow:0 3px 10px rgba(0,0,0,.18);
    pointer-events:none;
    transform: translate(-50%,-50%) translate(var(--rb-x, 0px), var(--rb-y, 0px));
  }

  /* ★追加：全員正体公開時は「表」を出すミニ正体カード */
  .role-front-mini{
    position:absolute;
    left:50%; top:50%;
    width:22px;height:30px;
    border-radius:6px;border:1px solid #ddd;
    background-size:cover;background-position:center;
    box-shadow:0 3px 10px rgba(0,0,0,.18);
    pointer-events:none;
    transform: translate(-50%,-50%) translate(var(--rb-x, 0px), var(--rb-y, 0px));
  }

  .ajito-card{
    position:absolute;
    left:50%; top:50%;
    width:34px; height:48px;
    border-radius:9px;
    border:1px solid #ddd;
    background-image:url('ajitoura.jpg');
    background-size:cover; background-position:center;
    box-shadow:0 6px 16px rgba(0,0,0,.22);
    transform: translate(-50%,-50%) translate(var(--ajito-x, 0px), var(--ajito-y, 0px)) rotate(var(--ajito-rot, 0deg));
    transform-origin:center;
    pointer-events:none;
  }
  .ajito-card.mine{ pointer-events:auto; cursor:pointer; }
  .ajito-card.drop-ok{
    border-width:2px;
    box-shadow:0 0 0 3px rgba(0,0,0,.10), 0 6px 16px rgba(0,0,0,.22);
  }

  .ajito-center{
    position:absolute; left:50%; top:50%;
    width:34px; height:48px;
    transform:translate(-50%,-50%);
    border-radius:9px;border:1px solid #ddd;
    background-image:url('ajitoura.jpg');
    background-size:cover; background-position:center;
    box-shadow:0 6px 16px rgba(0,0,0,.22);
    pointer-events:none;
  }
  .ajito-center.hidden{ display:none; }
  .ajito-center.drop-ok{
    border-width:2px;
    box-shadow:0 0 0 3px rgba(0,0,0,.10), 0 6px 16px rgba(0,0,0,.22);
  }

  .chiparea{
    position:absolute;
    left:50%; top:50%;
    width:54px; height:54px;
    border-radius:999px;
    border:2px solid #111;
    background:transparent;
    box-shadow:none;
    pointer-events:none;
    transform: translate(-50%,-50%) translate(var(--chip-x, 0px), var(--chip-y, 0px));
  }
  .chiparea.center{
    transform: translate(-50%,-50%);
  }
  .chiparea.drop-ok{
    border-width:3px;
    box-shadow:0 0 0 3px rgba(0,0,0,.08);
  }

  .colorcard{
    width:22px;height:30px;
    border-radius:7px;
    box-sizing:border-box;
    border:2px solid var(--cc-border, #111);
    background:
      repeating-linear-gradient(
        to bottom,
        var(--cc-dark, #333) 0px,
        var(--cc-dark, #333) 6px,
        var(--cc-light, #999) 6px,
        var(--cc-light, #999) 12px
      );
    box-shadow:0 6px 14px rgba(0,0,0,.22);
    overflow:hidden;
    position:relative;
    flex:0 0 auto;
    transform-origin:center;
  }
  .colorcard::after{
    content:'';
    position:absolute; inset:0;
    background-image:url('coloromote.png');
    background-position:center;
    background-repeat:no-repeat;
    background-size:100% 100%;
    opacity:.95;
    pointer-events:none;
  }

  .tag-color-wrap{
    position:absolute;
    left:0; top:50%;
    transform: translate(-140%, -50%);
    pointer-events:none;
  }
  .tag-color-wrap .colorcard{ pointer-events:none; }
  .player-tag.me .tag-color-wrap{ display:none; }

  /* ===== ★ 3時/9時だけ：ネームタグの下へ ===== */
  .player-tag.pos-3 .tag-color-wrap,
  .player-tag.pos-9 .tag-color-wrap{
    left:50%;
    top:100%;
    transform: translate(-50%, 6px);
  }

  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{display:flex;justify-content:center;gap:8px;margin-top:6px;min-height:110px;align-items:center;flex-wrap:wrap;}

  .my-role-card{
    width:80px;height:120px;border-radius:12px;border:1px solid #ddd;background:#fff;
    box-shadow:0 10px 26px rgba(0,0,0,.20);
    background-size:cover;background-position:center;
  }

  .colorcard.my-right{
    width:62px; height:92px;
    border-radius:12px;
    border-width:3px;
  }
  .colorcard.my-right::after{ background-size:100% 100%; }

  /* ===== Attack card ===== */
  .attackcard{
    width:62px;height:92px;border-radius:12px;border:1px solid #ddd;background:#fff;
    box-shadow:0 10px 26px rgba(0,0,0,.20);
    background-size:cover;background-position:center;
    transform-origin:center;
    position:relative;
    flex:0 0 auto;
  }
  .attackcard.draggable{ cursor:grab; touch-action:none; }
  .attackcard.draggable:active{ cursor:grabbing; }

  /* =========================
     ★大小アニメ（控えめ）
     ========================= */
  @keyframes turnPulse {
    0%   { transform:scale(1); }
    50%  { transform:scale(1.08); }
    100% { transform:scale(1); }
  }
  .turn-pulse{ animation: turnPulse 0.92s ease-in-out infinite; }

  .draggable{ cursor:grab; touch-action:none; }
  .draggable:active{ cursor:grabbing; }

  .drag-ghost{
    position:fixed;
    left:0; top:0;
    transform:translate(-50%,-50%);
    z-index:9999;
    pointer-events:none;
    opacity:.92;
    will-change: left, top, transform;
  }

  /* =========================
     ★ chipareaに溜まるミニ色カード
     ========================= */
  .pile-holder{
    position:absolute;
    left:50%; top:50%;
    pointer-events:none;
    transform: translate(-50%,-50%) translate(var(--pile-x, 40px), var(--pile-y, 0px));
  }

  .placed-color{
    position:absolute;
    left:0; top:0;
    width:20px; height:28px;
    border-radius:7px;
    border-width:2px;
    box-shadow:0 6px 14px rgba(0,0,0,.22);
    transform: translate(var(--pc-x, 0px), var(--pc-y, 0px)) rotate(30deg);
    pointer-events:none;
  }
  .placed-color::after{ display:none; }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}

  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
    border-bottom:1px dashed #eee;
  }
  .role-row:last-child{border-bottom:none;}
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    background-size:cover;background-position:center;
  }
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  .peek-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center;
    z-index:320;
  }
  .peek-backdrop.hidden{ display:none; }
  .peek-card{
    width:120px; height:170px;
    border-radius:16px; border:1px solid #ddd;
    background:#fff;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    background-size:cover; background-position:center;
  }

  /* ===== 中央アジト左：Attack Deck（0.8倍） ===== */
  .attack-deck{
    position:absolute;
    left:50%; top:50%;
    width:27px; height:38px;
    border-radius:8px;
    border:1px solid #ddd;
    background-image:url('attackura.jpg');
    background-size:cover;background-position:center;
    box-shadow:0 6px 16px rgba(0,0,0,.22);
    transform:translate(-50%,-50%) translate(-46px, 0px);
    z-index:50;
    pointer-events:none;
  }
  .attack-deck.hidden{ display:none; }
  .deck-count{
    position:absolute; right:-6px; top:-8px;
    min-width:18px; height:18px;
    padding:0 5px;
    border-radius:999px;
    background:#111; color:#fff;
    display:grid; place-items:center;
    font-size:11px; font-weight:800;
    border:1px solid rgba(255,255,255,.65);
    box-shadow:0 6px 14px rgba(0,0,0,.18);
  }

  /* ===== Challenge UI（中央） ===== */
  .challenge-board{
    position:fixed;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:min(320px, calc(100% - 24px));
    background:rgba(255,255,255,.96);
    border:1px solid #ddd;
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:330;
    padding:10px 10px 12px;
  }
  .challenge-board.hidden{ display:none; }

  /* ★提出ボックスを閉じる（強制非表示） */
  .challenge-board.ui-closed{ display:none !important; }

  .challenge-head{
    display:flex; align-items:center; justify-content:center;
    margin-bottom:8px;
  }
  .challenge-head > div:first-child{ display:none; }
  .challenge-title, .challenge-sub{ display:none; }

  /* ★ここに「提出：X枚」などが出る */
  #challengeNeed{
    font-weight:900;
    font-size:14px;
    opacity:1;
    text-align:center;
    white-space:nowrap;
  }

  .challenge-zone{
    border:2px dashed #111;
    border-radius:14px;
    min-height:104px;
    padding:6px;
    display:flex;
    align-items:center;
    justify-content:center;
    align-content:center;
    gap:8px;
    flex-wrap:wrap;
    background:transparent;
  }
  .challenge-zone.drop-ok{
    box-shadow:0 0 0 4px rgba(0,0,0,.08);
    border-style:solid;
  }

  .challenge-msg{ display:none; }

  .reveal-row{
    margin-top:10px;
    display:none;
  }

  /* ===== シャッフル：白ボックス透明化してカードだけ残す ===== */
  .challenge-board.stage-shuffle{
    background:transparent;
    border-color:transparent;
    box-shadow:none;
  }
  .challenge-board.stage-shuffle .challenge-head{ display:none; }
  .challenge-board.stage-shuffle .challenge-zone{
    border:none;
    padding:0;
    min-height:auto;
    justify-content:center;
  }
  .challenge-board.stage-shuffle .challenge-zone.drop-ok{
    box-shadow:none;
    border-style:none;
  }

  /* ===== シャッフル：左右中央で混ぜて→再度横に広がる（0.9s） ===== */
  .shuffle-stage{
    position:relative;
    width:min(300px, 92vw);
    height:120px;
  }
  .shuffle-stage .attackcard{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%) translateX(var(--sx,0px)) rotate(var(--rot,0deg));
    animation: shuffleCard 0.90s cubic-bezier(.22,.84,.44,1) forwards;
    will-change: transform;
  }
  @keyframes shuffleCard{
    0%   { transform:translate(-50%,-50%) translateX(var(--sx,0px)) rotate(var(--rot,0deg)); }
    20%  { transform:translate(-50%,-50%) translateX(0px) rotate(0deg); }
    35%  { transform:translate(-50%,-50%) translateX(18px) rotate(5deg); }
    50%  { transform:translate(-50%,-50%) translateX(-18px) rotate(-5deg); }
    65%  { transform:translate(-50%,-50%) translateX(12px) rotate(4deg); }
    75%  { transform:translate(-50%,-50%) translateX(0px) rotate(0deg); }
    100% { transform:translate(-50%,-50%) translateX(var(--sx,0px)) rotate(var(--rot,0deg)); }
  }

  /* ===== 倒れるアニメ：表示後2秒待ってから ===== */
  @keyframes flopBack {
    0% { transform:perspective(600px) rotateX(0deg) translateY(0px); }
    100%{ transform:perspective(600px) rotateX(75deg) translateY(10px); }
  }
  .flop{
    animation: flopBack .55s cubic-bezier(.22,.84,.44,1) forwards;
    animation-delay:2s;
    transform-origin:bottom;
  }

  /* ===== 決定ボタン：画面右下 ===== */
  .decide-fixed{
    position:fixed;
    right:16px; bottom:16px;
    width:64px; height:64px;
    border-radius:50%;
    border:1px solid rgba(255,255,255,.9);
    background:#16a34a;
    color:#fff;
    font-weight:900;
    font-size:12px;
    display:grid;
    place-items:center;
    box-shadow:0 12px 28px rgba(0,0,0,.22);
    cursor:pointer;
    user-select:none;
    z-index:380;
  }
  .decide-fixed.hidden{ display:none; }
  .decide-fixed.redo{ background:#111; }

  /* =========================
     ★ アジト：結果演出（中央拡大アニメ1.5秒）
     ========================= */
  .ajito-focus-backdrop{
    position:fixed; inset:0;
    display:grid; place-items:center;
    background:rgba(0,0,0,.22);
    z-index:390;
    pointer-events:none;
    opacity:0;
    transition:opacity .18s ease;
  }
  .ajito-focus-backdrop.show{ opacity:1; }

  .ajito-focus-card{
    width:150px; height:212px;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.65);
    background:#fff;
    background-size:cover; background-position:center;
    box-shadow:0 22px 56px rgba(0,0,0,.40);
    transform: translateY(10px) scale(.94);
    opacity:0;
    transition:transform .18s cubic-bezier(.22,.84,.44,1), opacity .18s ease;
    will-change: transform, opacity;
    position:relative;
    overflow:hidden;
  }
  .ajito-focus-backdrop.show .ajito-focus-card{
    transform: translateY(0px) scale(1);
    opacity:1;
  }

  @keyframes ajitoZoomOnce{
    0%   { transform: translateY(0px) scale(0.92); }
    20%  { transform: translateY(0px) scale(1.00); }
    60%  { transform: translateY(0px) scale(1.12); }
    100% { transform: translateY(0px) scale(1.00); }
  }
  .zoom-once{
    animation: ajitoZoomOnce 1.50s cubic-bezier(.22,.84,.44,1) 1;
  }

  /* BOOM：散る（破片を飞ばす） */
  .boom-layer{
    position:absolute; inset:0;
    pointer-events:none;
  }
  .boom-piece{
    position:absolute;
    left:50%; top:50%;
    width:62px; height:88px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.55);
    background-size:cover; background-position:center;
    box-shadow:0 14px 30px rgba(0,0,0,.28);
    transform: translate(-50%,-50%) translate(0px,0px) rotate(0deg) scale(1);
    opacity:1;
    animation: boomPiece 1.10s cubic-bezier(.22,.84,.44,1) forwards;
  }
  @keyframes boomPiece{
    0%   { transform: translate(-50%,-50%) translate(0px,0px) rotate(0deg) scale(1); opacity:1; }
    100% { transform: translate(-50%,-50%) translate(var(--dx, 80px), var(--dy, -60px)) rotate(var(--dr, 30deg)) scale(.92); opacity:0; }
  }

  /* =========================
     ★ アジト：集合→中央シャッフル→再配布（完全作り直し）
     ========================= */
  .ajito-anim-layer{
    position:fixed; inset:0;
    pointer-events:none;
    z-index:385; /* focusより下、challengeより上 */
  }

  .ajito-fly{
    position:fixed;
    width:34px; height:48px;
    border-radius:9px;
    border:1px solid rgba(255,255,255,.55);
    background-image:url('ajitoura.jpg');
    background-size:cover; background-position:center;
    box-shadow:0 14px 30px rgba(0,0,0,.22);
    left:0; top:0;

    --mx:0px;
    --my:0px;
    --rot:0deg;

    transform: translate(-50%,-50%) translate(var(--mx), var(--my)) rotate(var(--rot));
    will-change: transform, opacity;
    opacity:1;
    transition: transform 1.50s cubic-bezier(.22,.84,.44,1), opacity 1.50s ease;
  }

  @keyframes ajitoCenterShuffle {
    0%   { transform: translate(-50%,-50%) translate(var(--mx), var(--my)) rotate(var(--rot)); }
    12%  { transform: translate(-50%,-50%) translate(calc(var(--mx) + 14px), calc(var(--my) - 2px)) rotate(calc(var(--rot) + 7deg)); }
    24%  { transform: translate(-50%,-50%) translate(calc(var(--mx) - 14px), calc(var(--my) + 2px)) rotate(calc(var(--rot) - 7deg)); }
    36%  { transform: translate(-50%,-50%) translate(calc(var(--mx) + 12px), calc(var(--my) + 1px)) rotate(calc(var(--rot) + 6deg)); }
    48%  { transform: translate(-50%,-50%) translate(calc(var(--mx) - 12px), calc(var(--my) - 1px)) rotate(calc(var(--rot) - 6deg)); }
    60%  { transform: translate(-50%,-50%) translate(calc(var(--mx) + 10px), var(--my)) rotate(calc(var(--rot) + 4deg)); }
    72%  { transform: translate(-50%,-50%) translate(calc(var(--mx) - 10px), var(--my)) rotate(calc(var(--rot) - 4deg)); }
    84%  { transform: translate(-50%,-50%) translate(calc(var(--mx) + 6px), var(--my)) rotate(calc(var(--rot) + 2deg)); }
    100% { transform: translate(-50%,-50%) translate(var(--mx), var(--my)) rotate(var(--rot)); }
  }
  .center-shuffle{
    animation: ajitoCenterShuffle 1.50s cubic-bezier(.22,.84,.44,1) 1;
  }

  /* 公開されたアジトの“強調”だけ（transform触らずに光らせる） */
  @keyframes revealedGlow {
    0%   { filter:brightness(1); box-shadow:0 6px 16px rgba(0,0,0,.22); }
    40%  { filter:brightness(1.18); box-shadow:0 0 0 3px rgba(255,255,255,.50), 0 10px 26px rgba(0,0,0,.28); }
    100% { filter:brightness(1); box-shadow:0 6px 16px rgba(0,0,0,.22); }
  }
  .just-revealed{ animation: revealedGlow .55s ease 1; }
</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">
      <div id="ajitoCenterChip" class="chiparea center hidden"></div>
      <div id="ajitoCenter" class="ajito-center hidden"></div>
      <div id="attackDeckEl" class="attack-deck hidden">
        <div id="attackDeckCount" class="deck-count">0</div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<div id="challengeBoard" class="challenge-board hidden" aria-label="挑戦">
  <div class="challenge-head">
    <div>
      <div class="challenge-title" id="challengeTitle">挑戦</div>
      <div class="challenge-sub" id="challengeSub">カードを中央へドラッグして選択</div>
    </div>
    <div class="challenge-sub" id="challengeNeed">提出：0枚</div>
  </div>
  <div id="challengeZone" class="challenge-zone"></div>
  <div class="challenge-msg" id="challengeMsg"></div>
  <div class="reveal-row" id="revealRow"></div>
</div>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="ajitoPeekBackdrop" class="peek-backdrop hidden">
  <div id="ajitoPeekCard" class="peek-card"></div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で全プレイヤーに<br>
    ・正体カード（1枚）<br>
    ・アジトカード（各1枚＋中央1枚）<br>
    ・Attackデッキ<br>
    を配布します。<br>
    「リセット」で配布情報を消します。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<!-- ★決定ボタン：画面右下（必要枚数出すまで hidden のまま） -->
<button id="decideFixedBtn" class="decide-fixed hidden">決定</button>

<!-- ★アジト結果：中央拡大（1.5秒） -->
<div id="ajitoFocusBackdrop" class="ajito-focus-backdrop hidden" aria-hidden="true">
  <div id="ajitoFocusCard" class="ajito-focus-card"></div>
</div>

<!-- ★アジト：集合→シャッフル→再配布 レイヤー -->
<div id="ajitoAnimLayer" class="ajito-anim-layer"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove, runTransaction, push
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const IMG = {
  role_swat: 'roleswat.jpg',
  role_tero: 'roletero.jpg',
  role_back: 'roleura.jpg',

  ajito_back: 'ajitoura.jpg',
  ajito_boom: 'ajitoboom.jpg',
  ajito_dummy: 'ajitoshiin.jpg',
  ajito_hideout: 'ajitohideout.jpg',

  attack_back: 'attackura.jpg',
  atk_swat: 'swat.jpg',
  atk_tero: 'terrorist.jpg',
  atk_expert: 'expertswat.jpg',
  atk_super: 'superterrorist.jpg',
};

function attackTypeToImg(type){
  if (type === 'swat') return IMG.atk_swat;
  if (type === 'expertswat') return IMG.atk_expert;
  if (type === 'terrorist') return IMG.atk_tero;
  if (type === 'superterrorist') return IMG.atk_super;
  return IMG.attack_back;
}

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  room: {},            // ★ room.rolesOpen をここで参照
  roles: {},
  ajito: {},
  ajitoCenter: null,

  turn: null,
  placedDrops: {
    player: {},
    center: {}
  },

  attackDeck: null,
  challenge: null,

  colorByUserId: {},
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');
const ajitoCenterEl = document.getElementById('ajitoCenter');
const ajitoCenterChipEl = document.getElementById('ajitoCenterChip');

const attackDeckEl = document.getElementById('attackDeckEl');
const attackDeckCountEl = document.getElementById('attackDeckCount');

const challengeBoard = document.getElementById('challengeBoard');
const challengeNeed = document.getElementById('challengeNeed');
const challengeZone = document.getElementById('challengeZone');
const revealRow = document.getElementById('revealRow');

const decideFixedBtn = document.getElementById('decideFixedBtn');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const ajitoPeekBackdrop = document.getElementById('ajitoPeekBackdrop');
const ajitoPeekCard = document.getElementById('ajitoPeekCard');

/* ★アジト結果演出 */
const ajitoFocusBackdrop = document.getElementById('ajitoFocusBackdrop');
const ajitoFocusCard = document.getElementById('ajitoFocusCard');
const ajitoAnimLayer = document.getElementById('ajitoAnimLayer');

/* ★ 6色（赤、青、明るい黄、濃い緑、黒、白） */
const COLOR6 = [
  /* 赤 */   { light:'#ef4444', dark:'#7f1d1d', border:'#7f1d1d' },
  /* 青 */   { light:'#3b82f6', dark:'#1e3a8a', border:'#1e3a8a' },
  /* 黄 */   { light:'#fde047', dark:'#a16207', border:'#a16207' },
  /* 濃緑 */ { light:'#22c55e', dark:'#14532d', border:'#14532d' },
  /* 黒 */   { light:'#4b5563', dark:'#111111', border:'#111111' },
  /* 白 */   { light:'#f9fafb', dark:'#d1d5db', border:'#9ca3af' },
];

function hashToIndex(str, mod){
  let h = 2166136261;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return Math.abs(h) % mod;
}
function rebuildColorMap(players){
  const map = {};
  players.slice(0, COLOR6.length).forEach((p, i) => {
    map[p.id] = COLOR6[i];
  });
  state.colorByUserId = map;
}
function getColorForUserId(uid){
  if (uid && state.colorByUserId && state.colorByUserId[uid]) return state.colorByUserId[uid];
  const idx = hashToIndex(uid || '', COLOR6.length);
  return COLOR6[idx];
}
function makeColorCardEl(uid, extraClass=''){
  const c = getColorForUserId(uid);
  const el = document.createElement('div');
  el.className = `colorcard ${extraClass}`.trim();
  el.style.setProperty('--cc-light', c.light);
  el.style.setProperty('--cc-dark', c.dark);
  el.style.setProperty('--cc-border', c.border || c.dark);
  return el;
}

function makeAttackCardEl(cardObj, faceUp=true, extraClass=''){
  const el = document.createElement('div');
  el.className = `attackcard ${extraClass}`.trim();
  el.dataset.cardId = cardObj?.id || '';
  el.dataset.cardType = cardObj?.type || '';
  el.style.backgroundImage = `url('${faceUp ? attackTypeToImg(cardObj.type) : IMG.attack_back}')`;
  return el;
}

function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

/* ====== ヘルプ ====== */
const ROLE_HELP = [
  { key:"swat", name:"スワット", img: IMG.role_swat, text:"市民側（スワット）です。" },
  { key:"tero", name:"テロリスト", img: IMG.role_tero, text:"敵側（テロリスト）です。" },
];

function roleKeyToName(type){
  return (type === 'tero') ? 'テロリスト' : 'スワット';
}
function renderHelpList(){
  helpBody.innerHTML = '';

  const opened = !!state.room?.rolesOpen;

  // ★全員正体公開後：プレイヤー一覧（名前＋表カード）
  if (opened){
    const players = (latestPlayers || []);
    players.forEach((p) => {
      const r = state.roles?.[p.id]?.type;
      const row = document.createElement('div');
      row.className = 'role-row';

      const card = document.createElement('div');
      card.className = 'role-card';
      if (r){
        card.style.backgroundImage = `url('${roleTypeToImg(r)}')`;
      } else {
        card.style.backgroundImage = `url('${IMG.role_back}')`;
      }

      const desc = document.createElement('div');
      desc.className = 'role-desc';
      desc.innerHTML = `
        <div class="name">${p.name}</div>
        <div class="text">${r ? `正体：${roleKeyToName(r)}` : '正体：未配布'}</div>
      `;
      row.appendChild(card);
      row.appendChild(desc);
      helpBody.appendChild(row);
    });
    return;
  }

  // 未公開：ルール説明
  ROLE_HELP.forEach((r) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    card.style.backgroundImage = `url('${r.img}')`;

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;
    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

/* ====== アジトプレビュー ====== */
function ajitoTypeToImg(type){
  if (type === 'boom') return IMG.ajito_boom;
  if (type === 'dummy') return IMG.ajito_dummy;
  return IMG.ajito_hideout;
}
function openAjitoPeek(type){
  ajitoPeekCard.style.backgroundImage = `url('${ajitoTypeToImg(type)}')`;
  ajitoPeekBackdrop.classList.remove('hidden');
}
function closeAjitoPeek(){
  ajitoPeekBackdrop.classList.add('hidden');
}
ajitoPeekBackdrop.addEventListener('click', (e) => {
  if (e.target === ajitoPeekBackdrop) closeAjitoPeek();
});

/* ====== アジト結果演出（中央：拡大1.5秒） ====== */
let focusHideTimer = null;
function hideAjitoFocus(){
  if (focusHideTimer) clearTimeout(focusHideTimer);
  focusHideTimer = null;
  ajitoFocusBackdrop.classList.add('hidden');
  ajitoFocusBackdrop.classList.remove('show');
  ajitoFocusCard.classList.remove('zoom-once');
  ajitoFocusCard.innerHTML = '';
}
function showAjitoFocus(type, mode){
  hideAjitoFocus();
  ajitoFocusCard.style.backgroundImage = `url('${ajitoTypeToImg(type)}')`;
  ajitoFocusBackdrop.classList.remove('hidden');
  requestAnimationFrame(() => ajitoFocusBackdrop.classList.add('show'));

  requestAnimationFrame(() => {
    ajitoFocusCard.classList.remove('zoom-once');
    void ajitoFocusCard.offsetWidth;
    ajitoFocusCard.classList.add('zoom-once');
  });

  if (mode === 'boom'){
    const layer = document.createElement('div');
    layer.className = 'boom-layer';
    const pieceCount = 10;

    for (let i=0;i<pieceCount;i++){
      const p = document.createElement('div');
      p.className = 'boom-piece';
      p.style.backgroundImage = `url('${ajitoTypeToImg(type)}')`;

      const angle = (Math.PI * 2) * (i / pieceCount) + (Math.random()*0.5 - 0.25);
      const dist  = 120 + Math.random()*90;
      const dx = Math.cos(angle) * dist;
      const dy = Math.sin(angle) * dist - (30 + Math.random()*60);
      const dr = (Math.random()*120 - 60);

      p.style.setProperty('--dx', `${dx.toFixed(0)}px`);
      p.style.setProperty('--dy', `${dy.toFixed(0)}px`);
      p.style.setProperty('--dr', `${dr.toFixed(0)}deg`);

      layer.appendChild(p);
    }
    ajitoFocusCard.appendChild(layer);
  }

  // 1.5秒アニメ＋余裕
  focusHideTimer = setTimeout(() => hideAjitoFocus(), 1700);
}

/* =========================
   ★ アジト：集合→中央シャッフル→再配布（完全作り直し）
   - 集めている間：該当スロットのアジトは消える（visibility:hidden）
   - アニメ中：renderPlayerCircle が DOM を壊さないように一時停止
   ========================= */
let ajitoRedealLock = false;
let ajitoAnimPlaying = false;     // ★サークル再描画ブロック用
let pendingCircleRender = false;  // ★アニメ中に来た再描画要求

function requestRenderPlayerCircle(){
  if (!latestPlayers.length) return;
  if (ajitoAnimPlaying){
    pendingCircleRender = true;
    return;
  }
  renderPlayerCircle(latestPlayers);
}
function flushRenderPlayerCircle(){
  if (pendingCircleRender && !ajitoAnimPlaying && latestPlayers.length){
    pendingCircleRender = false;
    renderPlayerCircle(latestPlayers);
  }
}

function getSlotEl(slotKey){
  if (slotKey === 'c:center'){
    if (ajitoCenterEl.classList.contains('hidden')) return null;
    return ajitoCenterEl;
  }
  if (slotKey.startsWith('p:')){
    const uid = slotKey.slice(2);
    return playerCircle.querySelector(`.ajito-card[data-ajito-owner="${uid}"]`);
  }
  return null;
}

// ===== スクロールロック（アジトシャッフル中の位置ズレ対策）=====
let _mainScrollLock = null;

function lockMainScroll(){
  if (_mainScrollLock) return;

  const prev = {
    overflow: mainEl.style.overflow,
    touchAction: mainEl.style.touchAction,
    scrollTop: mainEl.scrollTop,
    scrollLeft: mainEl.scrollLeft,
  };

  const prevent = (e) => { e.preventDefault(); };

  mainEl.style.overflow = 'hidden';
  mainEl.style.touchAction = 'none';

  mainEl.scrollTop = prev.scrollTop;
  mainEl.scrollLeft = prev.scrollLeft;

  mainEl.addEventListener('wheel', prevent, { passive:false });
  mainEl.addEventListener('touchmove', prevent, { passive:false });

  _mainScrollLock = { prev, prevent };
}

function unlockMainScroll(){
  if (!_mainScrollLock) return;

  const { prev, prevent } = _mainScrollLock;
  mainEl.removeEventListener('wheel', prevent);
  mainEl.removeEventListener('touchmove', prevent);

  mainEl.style.overflow = prev.overflow;
  mainEl.style.touchAction = prev.touchAction;

  _mainScrollLock = null;
}

function centerPoint(){
  const r = playerCircle.getBoundingClientRect();
  return { x: r.left + r.width/2, y: r.top + r.height/2 };
}

function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

function setSlotsVisibility(slotKeys, visible){
  slotKeys.forEach((k) => {
    const el = getSlotEl(k);
    if (!el) return;
    el.style.visibility = visible ? '' : 'hidden';
  });
}

async function runAjitoRedealAnim(sourceSlots, destSlots){
  if (ajitoRedealLock) return;
  ajitoRedealLock = true;
  ajitoAnimPlaying = true;

  const ALL = Array.from(new Set([...(sourceSlots||[]), ...(destSlots||[])]));
  try{
    lockMainScroll();

    const srcInfos = (sourceSlots||[])
      .map(k => ({ k, el: getSlotEl(k) }))
      .filter(x => x.el);

    if (!srcInfos.length){
      return;
    }

    setSlotsVisibility(ALL, false);

    const c = centerPoint();

    const destPoints = new Map();
    (destSlots||[]).forEach((k) => {
      const el = getSlotEl(k);
      if (!el) return;
      const r = el.getBoundingClientRect();
      destPoints.set(k, { x: r.left + r.width/2, y: r.top + r.height/2 });
    });

    const clones = [];
    srcInfos.forEach(({k, el}, i) => {
      const r = el.getBoundingClientRect();
      const start = { x: r.left + r.width/2, y: r.top + r.height/2 };

      const clone = document.createElement('div');
      clone.className = 'ajito-fly';
      clone.style.left = `${start.x}px`;
      clone.style.top  = `${start.y}px`;
      clone.style.backgroundImage = `url('${IMG.ajito_back}')`;
      clone.style.zIndex = String(2000 + i);

      clone.style.setProperty('--mx', '0px');
      clone.style.setProperty('--my', '0px');
      clone.style.setProperty('--rot', `${(Math.random()*10-5).toFixed(0)}deg`);

      ajitoAnimLayer.appendChild(clone);
      clones.push({ k, clone, start });
    });

    requestAnimationFrame(() => {
      clones.forEach((o, i) => {
        const mid = (clones.length - 1) / 2;
        const offX = (i - mid) * 4;
        const offY = (i % 2 ? 3 : -3) + (i-mid)*1;
        const rot  = (i - mid) * 5;

        const dx = (c.x - o.start.x) + offX;
        const dy = (c.y - o.start.y) + offY;

        o.clone.style.setProperty('--mx', `${dx.toFixed(0)}px`);
        o.clone.style.setProperty('--my', `${dy.toFixed(0)}px`);
        o.clone.style.setProperty('--rot', `${rot.toFixed(0)}deg`);
      });
    });
    await sleep(1500);

    shuffle(clones.slice()).forEach((o, idx) => {
      o.clone.style.zIndex = String(2100 + idx);
    });

    clones.forEach((o) => {
      o.clone.classList.remove('center-shuffle');
      void o.clone.offsetWidth;
      o.clone.classList.add('center-shuffle');
    });
    await sleep(1500);

    requestAnimationFrame(() => {
      clones.forEach((o, i) => {
        const destKey = (destSlots && destSlots[i]) ? destSlots[i] : (destSlots && destSlots[0]);
        const d = destPoints.get(destKey);
        if (!d){
          o.clone.style.opacity = '0';
          return;
        }
        const dx = (d.x - o.start.x);
        const dy = (d.y - o.start.y);
        o.clone.classList.remove('center-shuffle');
        o.clone.style.setProperty('--mx', `${dx.toFixed(0)}px`);
        o.clone.style.setProperty('--my', `${dy.toFixed(0)}px`);
        o.clone.style.setProperty('--rot', `${(Math.random()*14-7).toFixed(0)}deg`);
      });
    });
    await sleep(1500);

    clones.forEach(o => o.clone.remove());
    setSlotsVisibility(ALL, true);

  } finally {
    unlockMainScroll();
    ajitoAnimPlaying = false;
    ajitoRedealLock = false;
    flushRenderPlayerCircle();
  }
}

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

/* ====== 手番＆ドラッグ ====== */
function isChallengeActive(){
  return !!(state.challenge && state.challenge.active);
}
function isMyTurn(){
  if (isChallengeActive()) return false;
  return !!(state.turn && state.turn.activePlayerId === state.userId);
}
let dragCtx = null;
let placingLock = false;

function getDropTargets(){
  const targets = [];
  if (isChallengeActive()) return targets;

  const centerRevealed = !!state.ajitoCenter?.revealed;
  if (!centerRevealed){
    if (!ajitoCenterChipEl.classList.contains('hidden')){
      targets.push({ kind:'center', id:'center', el: ajitoCenterChipEl });
    }
    if (!ajitoCenterEl.classList.contains('hidden')){
      targets.push({ kind:'center', id:'center', el: ajitoCenterEl });
    }
  }

  playerCircle.querySelectorAll('.chiparea[data-chip-owner]').forEach(el => {
    const uid = el.dataset.chipOwner;
    if (state.ajito?.[uid]?.revealed) return;
    targets.push({ kind:'player', id: uid, el });
  });

  playerCircle.querySelectorAll('.ajito-card[data-ajito-owner]').forEach(el => {
    const uid = el.dataset.ajitoOwner;
    if (state.ajito?.[uid]?.revealed) return;
    targets.push({ kind:'player', id: uid, el });
  });

  return targets;
}

function startColorDrag(e, sourceEl){
  if (!isMyTurn()) return;
  if (placingLock) return;

  const targets = getDropTargets();
  if (!targets.length) return;

  e.preventDefault();

  const r = sourceEl.getBoundingClientRect();
  const ghost = makeColorCardEl(state.userId, 'drag-ghost');
  ghost.style.width = `${Math.max(18, r.width)}px`;
  ghost.style.height = `${Math.max(26, r.height)}px`;

  ghost.style.left = `${e.clientX}px`;
  ghost.style.top  = `${e.clientY}px`;

  document.body.appendChild(ghost);

  sourceEl.style.visibility = 'hidden';

  dragCtx = { sourceEl, ghost, targets, hover: null, pointerId: e.pointerId, kind:'color' };

  const clearHighlights = () => {
    dragCtx?.targets.forEach(t => t.el.classList.remove('drop-ok'));
  };

  const onMove = (ev) => {
    if (!dragCtx) return;
    moveGhost(ev);

    let found = null;
    for (const t of dragCtx.targets){
      const rect = t.el.getBoundingClientRect();
      if (pointInRect(ev.clientX, ev.clientY, rect)){
        found = t;
        break;
      }
    }
    clearHighlights();
    if (found) found.el.classList.add('drop-ok');
    dragCtx.hover = found;
  };

  const onUp = async () => {
    if (!dragCtx) return;
    window.removeEventListener('pointermove', onMove);

    const hover = dragCtx.hover;

    clearHighlights();
    dragCtx.ghost.remove();
    dragCtx.sourceEl.style.visibility = '';
    dragCtx = null;

    if (hover){
      await placeDropAndAdvanceTurn(hover.kind, hover.id);
    }
  };

  window.addEventListener('pointermove', onMove, { passive:false });
  window.addEventListener('pointerup', onUp, { once:true, passive:false });
}
function moveGhost(e){
  if (!dragCtx) return;
  dragCtx.ghost.style.left = `${e.clientX}px`;
  dragCtx.ghost.style.top  = `${e.clientY}px`;
}
function pointInRect(x, y, rect){
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}

async function placeDropAndAdvanceTurn(kind, targetId){
  if (!state.roomCode) return;
  if (!isMyTurn()) return;
  if (placingLock) return;
  if (isChallengeActive()) return;

  placingLock = true;
  try{
    const base = `rooms/${state.roomCode}`;
    const targetRef =
      (kind === 'center')
        ? ref(db, `${base}/placedDrops/center`)
        : ref(db, `${base}/placedDrops/player/${targetId}`);

    await push(targetRef, { from: state.userId, at: Date.now() });

    const ids = (latestPlayers || []).map(p => p.id);
    if (!ids.length) return;

    const nextId = (() => {
      const i = ids.indexOf(state.userId);
      if (i === -1) return ids[0];
      return ids[(i + 1) % ids.length];
    })();

    await runTransaction(
      ref(db, `${base}/turn`),
      (cur) => {
        if (!cur || cur.activePlayerId !== state.userId) return cur;
        return {
          ...cur,
          activePlayerId: nextId,
          turnNo: (cur.turnNo || 0) + 1,
          updatedAt: Date.now()
        };
      }
    );
  } finally {
    placingLock = false;
  }
}
function markDraggable(el){
  el.classList.add('draggable');
  el.style.pointerEvents = 'auto';
  el.addEventListener('pointerdown', (e) => startColorDrag(e, el));
}

/* ====== Attack deck build ====== */
function buildAttackDeck(n){
  const deck = [];
  const pushN = (type, count) => { for(let i=0;i<count;i++) deck.push(type); };

  if (n === 4){
    pushN('swat', 8); pushN('expertswat', 4);
    pushN('terrorist', 4); pushN('superterrorist', 4);
  } else if (n === 5){
    pushN('swat', 10); pushN('expertswat', 5);
    pushN('terrorist', 5); pushN('superterrorist', 5);
  } else if (n === 6){
    pushN('swat', 12); pushN('expertswat', 6);
    pushN('terrorist', 6); pushN('superterrorist', 6);
  } else {
    const sw = Math.max(8, n*2);
    const ex = Math.max(4, Math.ceil(n));
    const te = Math.max(4, Math.ceil(n));
    const su = Math.max(4, Math.ceil(n));
    pushN('swat', sw); pushN('expertswat', ex);
    pushN('terrorist', te); pushN('superterrorist', su);
  }
  return shuffle(deck);
}

/* ====== 挑戦ロジック ====== */
function getChallengeMyNeed(ch){
  const me = ch?.participants?.[state.userId];
  return me?.need || 0;
}
function getChallengeMyDealt(ch){
  const me = ch?.participants?.[state.userId];
  return Array.isArray(me?.dealt) ? me.dealt : [];
}
function getChallengeMyChosen(ch){
  const me = ch?.participants?.[state.userId];
  return Array.isArray(me?.chosen) ? me.chosen : [];
}
function isChallengeMyDecided(ch){
  const me = ch?.participants?.[state.userId];
  return !!me?.decided;
}
function isChallengeMyParticipant(ch){
  const me = ch?.participants?.[state.userId];
  return !!me;
}
function hasChallengeMyDealt(ch){
  const me = ch?.participants?.[state.userId];
  return Array.isArray(me?.dealt) && me.dealt.length > 0;
}

function scoreAttackType(t){
  if (t === 'swat') return 0;
  if (t === 'expertswat') return 1;
  if (t === 'terrorist') return -1;
  if (t === 'superterrorist') return -2;
  return 0;
}

/* ====== Attackドラッグ ====== */
let attackDrag = null;

function startAttackDrag(e, sourceEl, from){
  if (!state.roomCode) return;
  const ch = state.challenge;
  if (!ch?.active) return;
  if (ch.stage !== 'select') return;

  const myNeed = getChallengeMyNeed(ch);
  if (myNeed <= 0) return;

  if (isChallengeMyDecided(ch)) return;

  e.preventDefault();

  const rect = sourceEl.getBoundingClientRect();
  const ghost = sourceEl.cloneNode(true);
  ghost.classList.add('drag-ghost');
  ghost.style.width = rect.width + 'px';
  ghost.style.height = rect.height + 'px';
  ghost.style.pointerEvents = 'none';

  ghost.style.left = `${e.clientX}px`;
  ghost.style.top  = `${e.clientY}px`;

  document.body.appendChild(ghost);

  sourceEl.style.visibility = 'hidden';

  attackDrag = {
    from, sourceEl, ghost,
    cardId: sourceEl.dataset.cardId,
    hoverZone: false,
    pointerId: e.pointerId,
  };

  const clearZone = () => challengeZone.classList.remove('drop-ok');

  const onMove = (ev) => {
    if (!attackDrag) return;
    ghost.style.left = `${ev.clientX}px`;
    ghost.style.top  = `${ev.clientY}px`;

    const z = challengeZone.getBoundingClientRect();
    const inside = pointInRect(ev.clientX, ev.clientY, z);
    clearZone();
    if (inside) challengeZone.classList.add('drop-ok');
    attackDrag.hoverZone = inside;
  };

  const onUp = async (ev) => {
    window.removeEventListener('pointermove', onMove);
    clearZone();

    if (!attackDrag) return;
    const { from, cardId } = attackDrag;

    attackDrag.ghost.remove();
    attackDrag.sourceEl.style.visibility = '';
    const hoverZone = attackDrag.hoverZone;
    attackDrag = null;

    if (!cardId) return;

    if (from === 'hand'){
      if (hoverZone){
        await chooseAttackCard(cardId);
      }
    } else if (from === 'chosen'){
      const boardRect = challengeBoard.getBoundingClientRect();
      const isDown = ev.clientY > (boardRect.top + boardRect.height + 30);
      if (isDown){
        await unchooseAttackCard(cardId);
      }
    }
  };

  window.addEventListener('pointermove', onMove, { passive:false });
  window.addEventListener('pointerup', onUp, { once:true, passive:false });
}

async function chooseAttackCard(cardId){
  const ch = state.challenge;
  if (!ch?.active) return;
  if (ch.stage !== 'select') return;

  const myNeed = getChallengeMyNeed(ch);
  if (myNeed <= 0) return;

  const dealt = getChallengeMyDealt(ch);
  const chosen = getChallengeMyChosen(ch);

  const has = dealt.some(c => c.id === cardId);
  if (!has) return;

  let next = chosen.slice();
  if (next.includes(cardId)) return;

  if (next.length < myNeed){
    next.push(cardId);
  } else {
    next[myNeed - 1] = cardId;
  }

  await update(ref(db, `rooms/${state.roomCode}/challenge/participants/${state.userId}`), {
    chosen: next
  });
}

async function unchooseAttackCard(cardId){
  const ch = state.challenge;
  if (!ch?.active) return;
  if (ch.stage !== 'select') return;

  const chosen = getChallengeMyChosen(ch);
  const next = chosen.filter(id => id !== cardId);

  await update(ref(db, `rooms/${state.roomCode}/challenge/participants/${state.userId}`), {
    chosen: next,
    decided: false
  });
}

async function setMyDecided(nextDecided){
  if (!state.roomCode) return;
  const ch = state.challenge;
  if (!ch?.active) return;
  if (ch.stage !== 'select') return;

  await update(ref(db, `rooms/${state.roomCode}/challenge/participants/${state.userId}`), {
    decided: !!nextDecided
  });
}

decideFixedBtn.addEventListener('click', async () => {
  const ch = state.challenge;
  if (!ch?.active || ch.stage !== 'select') return;
  if (!isChallengeMyParticipant(ch) || !hasChallengeMyDealt(ch)) return;
  const myNeed = getChallengeMyNeed(ch);
  const myChosenLen = getChallengeMyChosen(ch).length;
  if (myNeed <= 0 || myChosenLen !== myNeed) return;
  const myDecided = isChallengeMyDecided(ch);
  await setMyDecided(!myDecided);
});

/* ====== 挑戦UI描画 ====== */
let lastMyDealtKey = '';
function renderChallengeUI(){
  const ch = state.challenge;

  const deckCount = state.attackDeck?.draw?.length ?? 0;
  const showDeck = !!(state.ajitoCenter && state.attackDeck && Array.isArray(state.attackDeck.draw));
  attackDeckEl.classList.toggle('hidden', !showDeck);
  if (showDeck) attackDeckCountEl.textContent = String(deckCount);

  decideFixedBtn.classList.add('hidden');
  decideFixedBtn.classList.remove('redo');

  if (!ch?.active){
    challengeBoard.classList.add('hidden');
    challengeBoard.classList.remove('stage-shuffle');
    challengeBoard.classList.remove('ui-closed');
    challengeZone.innerHTML = '';
    revealRow.innerHTML = '';
    lastMyDealtKey = '';
    return;
  }

  challengeBoard.classList.toggle('ui-closed', !!ch.uiClosed);
  if (ch.uiClosed){
    return;
  }

  challengeBoard.classList.remove('hidden');

  const myNeed = getChallengeMyNeed(ch);
  const myDealt = getChallengeMyDealt(ch);
  const myChosen = getChallengeMyChosen(ch);
  const myDecided = isChallengeMyDecided(ch);
  const isParticipant = isChallengeMyParticipant(ch);
  const hasDealt = hasChallengeMyDealt(ch);

  challengeBoard.classList.toggle('stage-shuffle', ch.stage === 'shuffle');

  if (ch.stage === 'select'){
    if (isParticipant && hasDealt && myNeed > 0){
      const left = Math.max(0, myNeed - myChosen.length);
      if (left > 0){
        challengeNeed.textContent = `提出：${myNeed}枚（${myChosen.length}/${myNeed}）  あと${left}`;
      } else {
        challengeNeed.textContent = `提出：${myNeed}枚（${myChosen.length}/${myNeed}）  ${myDecided ? '決定済み' : '決定してください'}`;
      }
    } else {
      challengeNeed.textContent = '提出なし';
    }
  } else if (ch.stage === 'shuffle'){
    challengeNeed.textContent = 'シャッフル中…';
  } else if (ch.stage === 'reveal'){
    const success = !!ch.result?.success;
    challengeNeed.textContent = success ? '成功' : '失敗';
  } else {
    challengeNeed.textContent = '';
  }

  challengeZone.innerHTML = '';
  revealRow.innerHTML = '';

  if (ch.stage === 'shuffle'){
    const stage = document.createElement('div');
    stage.className = 'shuffle-stage';

    const offsets = [-96, -32, 32, 96];
    const rots    = [-10, -4, 4, 10];

    for (let i=0;i<4;i++){
      const b = makeAttackCardEl({id:'', type:'swat'}, false, '');
      b.style.setProperty('--sx', offsets[i] + 'px');
      b.style.setProperty('--rot', rots[i] + 'deg');
      stage.appendChild(b);
    }
    challengeZone.appendChild(stage);

  } else if (ch.stage === 'reveal'){
    const types = Array.isArray(ch.revealed) ? ch.revealed : [];
    const success = !!ch.result?.success;

    types.forEach((t) => {
      const c = makeAttackCardEl({id:'', type:t}, true, '');
      const isTero = (t === 'terrorist' || t === 'superterrorist');
      const isSwat = (t === 'swat' || t === 'expertswat');

      if ((success && isTero) || (!success && isSwat)){
        c.classList.add('flop');
      }
      challengeZone.appendChild(c);
    });

  } else {
    const all = buildCentralChosenList(ch, true);
    all.forEach(cardView => challengeZone.appendChild(cardView.el));
  }

  if (ch.stage === 'select' && isParticipant && hasDealt && myNeed > 0 && myChosen.length === myNeed){
    decideFixedBtn.classList.remove('hidden');
    decideFixedBtn.textContent = myDecided ? 'やり直す' : '決定';
    if (myDecided) decideFixedBtn.classList.add('redo');
  }

  renderMyRole();

  if (ch.stage === 'select' && myDealt.length){
    const key = myDealt.map(c => c.id).join(',');
    if (key && key !== lastMyDealtKey){
      lastMyDealtKey = key;
      playDealAnimationForMe(myDealt);
    }
  }
}

function buildCentralChosenList(ch, faceUpForMe){
  const parts = ch.participants || {};
  const meId = state.userId;

  const others = [];
  const mine = [];

  for (const [uid, info] of Object.entries(parts)){
    const dealt = Array.isArray(info.dealt) ? info.dealt : [];
    const chosenIds = Array.isArray(info.chosen) ? info.chosen : [];
    const chosenObjs = chosenIds
      .map(id => dealt.find(c => c.id === id))
      .filter(Boolean);

    if (uid === meId){
      chosenObjs.forEach((c) => {
        const el = makeAttackCardEl(c, !!faceUpForMe, '');
        if (ch.stage === 'select' && !isChallengeMyDecided(ch)){
          el.classList.add('draggable');
          el.addEventListener('pointerdown', (e) => startAttackDrag(e, el, 'chosen'));
          el.classList.add('turn-pulse');
        }
        mine.push({uid, el, type:c.type});
      });
    } else {
      chosenObjs.forEach((c) => {
        const el = makeAttackCardEl(c, false, '');
        others.push({uid, el, type:c.type});
      });
    }
  }
  return [...others, ...mine];
}

function playDealAnimationForMe(myDealt){
  if (attackDeckEl.classList.contains('hidden')) return;

  const deckRect = attackDeckEl.getBoundingClientRect();
  const handRect = myHandEl.getBoundingClientRect();

  const flyN = Math.min(6, myDealt.length);
  for (let i=0;i<flyN;i++){
    const el = document.createElement('div');
    el.className = 'attackcard drag-ghost';
    el.style.backgroundImage = `url('${IMG.attack_back}')`;
    el.style.width = '62px';
    el.style.height = '92px';
    el.style.left = (deckRect.left + deckRect.width/2) + 'px';
    el.style.top  = (deckRect.top + deckRect.height/2) + 'px';
    el.style.opacity = '0.95';
    el.style.transition = 'transform .50s cubic-bezier(.22,.84,.44,1), opacity .50s';
    document.body.appendChild(el);

    const tx = (handRect.left + handRect.width/2) - (deckRect.left + deckRect.width/2) + (i*8);
    const ty = (handRect.top + handRect.height/2) - (deckRect.top + deckRect.height/2);

    requestAnimationFrame(() => {
      el.style.transform = `translate(-50%,-50%) translate(${tx}px, ${ty}px) rotate(${(i-2)*4}deg) scale(1.01)`;
      el.style.opacity = '0.18';
    });
    setTimeout(() => el.remove(), 620);
  }
}

/* ====== ホスト：挑戦開始判定 ====== */
let startingChallengeLock = false;

function getTop4FromObj(obj){
  const entries = Object.entries(obj || {})
    .map(([k,v]) => ({ key:k, ...(v||{}) }))
    .filter(x => x && x.from)
    .sort((a,b) => (a.at||0) - (b.at||0));
  return entries.slice(0,4);
}

function pickChallengeCandidate(){
  const candidates = [];

  if (state.placedDrops?.center){
    const all = Object.entries(state.placedDrops.center || {})
      .map(([k,v]) => ({ key:k, ...(v||{}) }))
      .filter(x => x && x.from)
      .sort((a,b) => (a.at||0)-(b.at||0));
    if (all.length >= 4){
      candidates.push({
        kind:'center',
        id:'center',
        fourthAt: all[3].at || 0
      });
    }
  }

  const pMap = state.placedDrops?.player || {};
  for (const [pid, obj] of Object.entries(pMap)){
    const all = Object.entries(obj || {})
      .map(([k,v]) => ({ key:k, ...(v||{}) }))
      .filter(x => x && x.from)
      .sort((a,b) => (a.at||0)-(b.at||0));
    if (all.length >= 4){
      candidates.push({
        kind:'player',
        id: pid,
        fourthAt: all[3].at || 0
      });
    }
  }

  if (!candidates.length) return null;
  candidates.sort((a,b) => (a.fourthAt||0) - (b.fourthAt||0));
  return candidates[0];
}

async function hostStartChallengeIfNeeded(){
  if (!state.isHost) return;
  if (!state.roomCode) return;
  if (startingChallengeLock) return;
  if (state.challenge?.active) return;

  const cand = pickChallengeCandidate();
  if (!cand) return;

  startingChallengeLock = true;
  try{
    await startChallenge(cand.kind, cand.id);
  } finally {
    startingChallengeLock = false;
  }
}

async function startChallenge(kind, id){
  const base = `rooms/${state.roomCode}`;
  const snap = await get(ref(db, `${base}/placedDrops`));
  const placed = snap.val() || {};
  const targetObj =
    (kind === 'center')
      ? (placed.center || {})
      : ((placed.player || {})[id] || {});

  const top4 = getTop4FromObj(targetObj);
  if (top4.length < 4) return;

  const needMap = {};
  top4.forEach(d => {
    needMap[d.from] = (needMap[d.from] || 0) + 1;
  });

  const deckSnap = await get(ref(db, `${base}/attackDeck`));
  let deck = deckSnap.val();
  if (!deck || !Array.isArray(deck.draw)){
    const n = latestPlayers.length || 4;
    deck = { draw: buildAttackDeck(n), discard: [] };
  }
  deck.draw = Array.isArray(deck.draw) ? deck.draw.slice() : [];
  deck.discard = Array.isArray(deck.discard) ? deck.discard.slice() : [];

  const ensureDraw = (needN) => {
    if (deck.draw.length >= needN) return;
    if (deck.discard.length){
      deck.draw = shuffle(deck.draw.concat(shuffle(deck.discard.slice())));
      deck.discard = [];
    }
  };

  const participants = {};
  for (const [uid, need] of Object.entries(needMap)){
    if (!need) continue;
    const dealCount = need * 2;
    ensureDraw(dealCount);

    const dealt = [];
    for (let i=0;i<dealCount;i++){
      if (!deck.draw.length){
        ensureDraw(1);
      }
      const type = deck.draw.pop();
      dealt.push({ id: crypto.randomUUID(), type });
    }
    participants[uid] = {
      need,
      dealt,
      chosen: [],
      decided: false
    };
  }

  const challenge = {
    active: true,
    stage: 'select',
    target: { kind, id },
    dropKeys: top4.map(d => d.key),
    startedAt: Date.now(),
    participants,
    postSeq: 0,
    post: null,
    uiClosed: false
  };

  await update(ref(db, base), {
    attackDeck: deck,
    challenge: challenge
  });
}

let hostShuffleTimer = null;
let hostRevealTimer = null;
let hostFinishTimer = null;

/* ★新时序用 */
let hostCloseSubmitTimer = null;
let hostRevealAjitoTimer = null;
let hostFocusAjitoTimer = null;
let hostRedealAjitoTimer = null;

/* ★追加：正体公開チェック用タイマー */
let hostRolesRevealTimer = null;

function clearHostTimers(){
  if (hostShuffleTimer) clearTimeout(hostShuffleTimer);
  if (hostRevealTimer) clearTimeout(hostRevealTimer);
  if (hostFinishTimer) clearTimeout(hostFinishTimer);
  if (hostCloseSubmitTimer) clearTimeout(hostCloseSubmitTimer);
  if (hostRevealAjitoTimer) clearTimeout(hostRevealAjitoTimer);
  if (hostFocusAjitoTimer) clearTimeout(hostFocusAjitoTimer);
  if (hostRedealAjitoTimer) clearTimeout(hostRedealAjitoTimer);
  if (hostRolesRevealTimer) clearTimeout(hostRolesRevealTimer);

  hostShuffleTimer = hostRevealTimer = hostFinishTimer = null;
  hostCloseSubmitTimer = hostRevealAjitoTimer = hostFocusAjitoTimer = hostRedealAjitoTimer = null;
  hostRolesRevealTimer = null;
}

async function hostCloseSubmitUI(){
  if (!state.isHost || !state.roomCode) return;
  const base = `rooms/${state.roomCode}`;
  const snap = await get(ref(db, `${base}/challenge`));
  const ch = snap.val();
  if (!ch?.active) return;
  if (ch.uiClosed) return;

  await update(ref(db, `${base}/challenge`), {
    uiClosed: true,
    postSeq: (ch.postSeq || 0) + 1,
    post: { type:'closeSubmit', at: Date.now() }
  });
}

/* =========================
   ★追加：正体公開条件
   - boom が公開され、拡大（focus）アニメが終わった後
   - すべての hideout が公開され、拡大（focus）アニメが終わった後
   ========================= */
function areAllHideoutsRevealed(room){
  room = room || {};
  const aj = room.ajito || {};
  for (const v of Object.values(aj)){
    if (!v || !v.type) continue;
    if (v.type === 'hideout' && !v.revealed) return false;
  }
  const c = room.ajitoCenter || null;
  if (c && c.type === 'hideout' && !c.revealed) return false;
  return true;
}

async function hostRevealAllRolesIfNeeded(reason){
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  const snap = await get(ref(db, base));
  const room = snap.val() || {};

  if (room.rolesOpen) return; // 既に公開済み

  const ch = room.challenge;
  const up = {
    rolesOpen: true,
    rolesOpenAt: Date.now(),
    rolesOpenReason: reason || 'unknown',
  };

  // ★挑戦中なら post も出して全員が同時に反応できるように
  if (ch?.active){
    up[`challenge/postSeq`] = (ch.postSeq || 0) + 1;
    up[`challenge/post`] = { type:'revealRoles', reason: reason || 'unknown', at: Date.now() };
  }

  await update(ref(db, base), up);
}

async function hostMaybeRevealRolesAfterFocus(){
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  const snap = await get(ref(db, base));
  const room = snap.val() || {};
  if (room.rolesOpen) return;

  const ch = room.challenge;
  if (!ch?.active) return;

  const post = ch.post || {};
  // focus の直後にだけ判定（「拡大カードアニメが終わったら」に合わせる）
  // ※タイマーで 1700ms 後に呼ぶので、この時点でアニメは終わってる
  const isBoom = !!post.isBoom;
  const allHideouts = areAllHideoutsRevealed(room);

  if (isBoom){
    await hostRevealAllRolesIfNeeded('boom');
    return;
  }
  if (allHideouts){
    await hostRevealAllRolesIfNeeded('allHideouts');
    return;
  }
}

function calcAttackDeckAfterChallenge(deck, ch){
  deck = deck || { draw: [], discard: [] };
  deck.draw = Array.isArray(deck.draw) ? deck.draw.slice() : [];
  deck.discard = Array.isArray(deck.discard) ? deck.discard.slice() : [];

  const revealed = Array.isArray(ch.revealed) ? ch.revealed : [];
  const allSwat = revealed.length === 4 && revealed.every(t => t === 'swat');

  const chosenTypes = [];
  const unusedTypes = [];

  for (const [uid, p] of Object.entries(ch.participants || {})){
    const dealt = Array.isArray(p.dealt) ? p.dealt : [];
    const chosenIds = Array.isArray(p.chosen) ? p.chosen : [];
    const chosenSet = new Set(chosenIds);

    dealt.forEach(c => {
      if (chosenSet.has(c.id)) chosenTypes.push(c.type);
      else unusedTypes.push(c.type);
    });
  }

  deck.draw = deck.draw.concat(unusedTypes);

  if (allSwat) deck.draw = deck.draw.concat(chosenTypes);
  else deck.discard = deck.discard.concat(chosenTypes);

  deck.draw = shuffle(deck.draw);
  return deck;
}

async function hostReturnAttackCardsToDeckIfNeeded(){
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  const snap = await get(ref(db, base));
  const room = snap.val() || {};
  const ch = room.challenge;

  if (!ch?.active) return;

  if (ch.cardsReturned) return;

  let deck = room.attackDeck;
  if (!deck || !Array.isArray(deck.draw)){
    const n = latestPlayers.length || 4;
    deck = { draw: buildAttackDeck(n), discard: [] };
  }

  deck = calcAttackDeckAfterChallenge(deck, ch);

  await update(ref(db, base), {
    attackDeck: deck,
    "challenge/cardsReturned": true,
    "challenge/cardsReturnedAt": Date.now(),
  });
}

async function hostRevealAjitoAndPost(){
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  const roomSnap = await get(ref(db, base));
  const room = roomSnap.val() || {};
  const ch = room.challenge;
  if (!ch?.active) return;

  const target = ch.target || {};
  const kind = target.kind;
  const tid  = target.id;

  let ajType = null;
  const up = {};

  if (kind === 'center'){
    const cur = room.ajitoCenter || null;
    ajType = cur?.type || null;
    up[`ajitoCenter/revealed`] = true;
  } else {
    const cur = (room.ajito || {})[tid] || null;
    ajType = cur?.type || null;
    up[`ajito/${tid}/revealed`] = true;
  }

  up[`challenge/postSeq`] = (ch.postSeq || 0) + 1;
  up[`challenge/post`] = {
    type: 'revealAjito',
    target: { kind, id: tid },
    ajitoType: ajType,
    isBoom: (ajType === 'boom'),
    at: Date.now()
  };

  await update(ref(db, base), up);
}

async function hostFocusAjitoAndPost(){
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  const roomSnap = await get(ref(db, base));
  const room = roomSnap.val() || {};
  const ch = room.challenge;
  if (!ch?.active) return;

  const prevPost = ch.post || {};
  const ajType = prevPost.ajitoType || null;
  const isBoom = !!prevPost.isBoom;
  if (!ajType) return;

  await update(ref(db, `${base}/challenge`), {
    postSeq: (ch.postSeq || 0) + 1,
    post: {
      type: 'focusAjito',
      ajitoType: ajType,
      isBoom: isBoom,
      at: Date.now()
    }
  });
}

/* ★ホスト：未公開アジトだけをシャッフル＆空きに再配布（DB＋post） */
async function hostDoAjitoRedealAndPost(){
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  const roomSnap = await get(ref(db, base));
  const room = roomSnap.val() || {};
  const chNow = room.challenge;
  if (!chNow?.active) return;

  const aj = room.ajito || {};
  const center = room.ajitoCenter || null;

  const slots = [];
  for (const [uid, v] of Object.entries(aj)){
    if (!v) continue;
    if (v.revealed) continue;
    if (!v.type) continue;
    slots.push(`p:${uid}`);
  }
  if (center && center.type && !center.revealed){
    slots.push('c:center');
  }

  if (slots.length <= 1){
    await update(ref(db, `${base}/challenge`), {
      postSeq: (chNow.postSeq || 0) + 1,
      post: { type:'redealAjito', sourceSlots: slots, destSlots: slots.slice(), at: Date.now() }
    });
    return;
  }

  const typeBySlot = new Map();
  slots.forEach((k) => {
    if (k === 'c:center'){
      typeBySlot.set(k, center.type);
    } else {
      const uid = k.slice(2);
      typeBySlot.set(k, aj[uid]?.type);
    }
  });

  const destSlots = shuffle(slots.slice());

  const up = {};
  slots.forEach((srcKey, i) => {
    const destKey = destSlots[i];
    const t = typeBySlot.get(srcKey);
    if (!t) return;

    if (destKey === 'c:center'){
      up[`ajitoCenter/type`] = t;
      up[`ajitoCenter/revealed`] = false;
    } else {
      const uid = destKey.slice(2);
      up[`ajito/${uid}/type`] = t;
      up[`ajito/${uid}/revealed`] = false;
    }
  });

  up[`challenge/postSeq`] = (chNow.postSeq || 0) + 1;
  up[`challenge/post`] = {
    type: 'redealAjito',
    sourceSlots: slots,
    destSlots: destSlots,
    at: Date.now()
  };

  await update(ref(db, base), up);
}

async function hostFinishChallenge(){
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  const snap = await get(ref(db, `${base}`));
  const room = snap.val() || {};
  const ch = room.challenge;
  if (!ch?.active) return;

  let deck = room.attackDeck;
  if (!deck || !Array.isArray(deck.draw)){
    const n = latestPlayers.length || 4;
    deck = { draw: buildAttackDeck(n), discard: [] };
  }
  if (!ch.cardsReturned){
    deck = calcAttackDeckAfterChallenge(deck, ch);
  }

  const target = ch.target || {};
  const kind = target.kind;
  const tid = target.id;
  const dropKeys = Array.isArray(ch.dropKeys) ? ch.dropKeys : [];

  const updates = {
    attackDeck: deck,
    challenge: null
  };

  dropKeys.forEach((k) => {
    if (kind === 'center'){
      updates[`placedDrops/center/${k}`] = null;
    } else {
      updates[`placedDrops/player/${tid}/${k}`] = null;
    }
  });

  await update(ref(db, base), updates);

  clearHostTimers();
}

async function hostProgressChallenge(){
  if (!state.isHost) return;
  const ch = state.challenge;
  if (!ch?.active) { clearHostTimers(); return; }

  if (ch.stage === 'select'){
    const parts = ch.participants || {};
    const uids = Object.keys(parts);
    if (!uids.length) return;

    const allDone = uids.every(uid => {
      const p = parts[uid] || {};
      const need = p.need || 0;
      const chosen = Array.isArray(p.chosen) ? p.chosen : [];
      return need > 0 && chosen.length === need && !!p.decided;
    });

    if (!allDone) return;
    if (hostShuffleTimer || hostRevealTimer || hostFinishTimer || hostCloseSubmitTimer || hostRedealAjitoTimer || hostRolesRevealTimer) return;

    await update(ref(db, `rooms/${state.roomCode}/challenge`), {
      stage: 'shuffle',
      shuffleAt: Date.now()
    });

    hostRevealTimer = setTimeout(async () => {
      const freshSnap = await get(ref(db, `rooms/${state.roomCode}/challenge`));
      const c2 = freshSnap.val();
      if (!c2?.active) return;

      const pool = [];
      for (const [uid, p] of Object.entries(c2.participants || {})){
        const dealt = Array.isArray(p.dealt) ? p.dealt : [];
        const chosenIds = Array.isArray(p.chosen) ? p.chosen : [];
        chosenIds.forEach(id => {
          const obj = dealt.find(x => x.id === id);
          if (obj) pool.push({ uid, ...obj });
        });
      }
      const picked = pool.slice(0,4);
      const types = picked.map(x => x.type);
      shuffle(types);

      const total = types.reduce((s,t) => s + scoreAttackType(t), 0);
      const success = total >= 0;

      await update(ref(db, `rooms/${state.roomCode}/challenge`), {
        stage: 'reveal',
        revealed: types,
        result: { total, success },
        revealedAt: Date.now(),
        postSeq: 0,
        post: null,
        uiClosed: false
      });

      const WAIT_AFTER_REVEAL_FLOP = 2600; // attack flop: 2.0s + 0.55s 余裕
      const WAIT_CLOSE_TO_REVEAL_AJITO = 2000;
      const WAIT_REVEAL_TO_FOCUS = 1000;
      const FOCUS_ANIM = 1500;
      const FOCUS_HIDE = 1700;             // ★showAjitoFocus の消えるタイミングに合わせる
      const WAIT_FOCUS_END_TO_REDEAL = 2000;

      const REDEAL_TOTAL = 1500 + 1500 + 1500 + 300; // 集合/洗/发 + 余裕

      clearHostTimers();

      hostCloseSubmitTimer = setTimeout(async () => {
        await hostReturnAttackCardsToDeckIfNeeded();
        await hostCloseSubmitUI();
      }, WAIT_AFTER_REVEAL_FLOP);

      if (success){
        hostRevealAjitoTimer = setTimeout(async () => {
          await hostRevealAjitoAndPost();
        }, WAIT_AFTER_REVEAL_FLOP + WAIT_CLOSE_TO_REVEAL_AJITO);

        hostFocusAjitoTimer = setTimeout(async () => {
          await hostFocusAjitoAndPost();
        }, WAIT_AFTER_REVEAL_FLOP + WAIT_CLOSE_TO_REVEAL_AJITO + WAIT_REVEAL_TO_FOCUS);

        /* ★追加：拡大カードアニメ終了後に「boom or 全hideout公開」なら全員正体公開 */
        hostRolesRevealTimer = setTimeout(async () => {
          await hostMaybeRevealRolesAfterFocus();
        }, WAIT_AFTER_REVEAL_FLOP + WAIT_CLOSE_TO_REVEAL_AJITO + WAIT_REVEAL_TO_FOCUS + FOCUS_HIDE);

        hostRedealAjitoTimer = setTimeout(async () => {
          await hostDoAjitoRedealAndPost();
        }, WAIT_AFTER_REVEAL_FLOP + WAIT_CLOSE_TO_REVEAL_AJITO + WAIT_REVEAL_TO_FOCUS + FOCUS_ANIM + WAIT_FOCUS_END_TO_REDEAL);

        hostFinishTimer = setTimeout(async () => {
          await hostFinishChallenge();
        }, WAIT_AFTER_REVEAL_FLOP + WAIT_CLOSE_TO_REVEAL_AJITO + WAIT_REVEAL_TO_FOCUS + FOCUS_ANIM + WAIT_FOCUS_END_TO_REDEAL + REDEAL_TOTAL);
      } else {
        hostRedealAjitoTimer = setTimeout(async () => {
          await hostDoAjitoRedealAndPost();
        }, WAIT_AFTER_REVEAL_FLOP + WAIT_CLOSE_TO_REVEAL_AJITO);

        hostFinishTimer = setTimeout(async () => {
          await hostFinishChallenge();
        }, WAIT_AFTER_REVEAL_FLOP + WAIT_CLOSE_TO_REVEAL_AJITO + REDEAL_TOTAL);
      }

    }, 900);
  }
}

/* ====== 購読 ====== */
function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();

    // ★rolesOpen が変わったら UI 更新（サークル/ヘルプ）
    requestRenderPlayerCircle();
    renderMyRole();
    if (!helpBackdrop.classList.contains('hidden')){
      renderHelpList();
    }
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
  });
}
function subscribeRoles(){
  const rolesRef = ref(db, `rooms/${state.roomCode}/roles`);
  onValue(rolesRef, snap => {
    state.roles = snap.val() || {};
    renderMyRole();
    requestRenderPlayerCircle();
    if (!helpBackdrop.classList.contains('hidden')){
      renderHelpList();
    }
  });
}
function subscribeAjito(){
  const ajRef = ref(db, `rooms/${state.roomCode}/ajito`);
  const centerRef = ref(db, `rooms/${state.roomCode}/ajitoCenter`);

  onValue(ajRef, snap => {
    state.ajito = snap.val() || {};
    requestRenderPlayerCircle();
  });
  onValue(centerRef, snap => {
    state.ajitoCenter = snap.val() || null;
    const hasCenter = !!state.ajitoCenter;
    ajitoCenterEl.classList.toggle('hidden', !hasCenter);
    ajitoCenterChipEl.classList.toggle('hidden', !hasCenter);
    requestRenderPlayerCircle();
  });
}
function subscribeTurnAndPlaced(){
  const tRef = ref(db, `rooms/${state.roomCode}/turn`);
  const pRef = ref(db, `rooms/${state.roomCode}/placedDrops`);

  onValue(tRef, snap => {
    state.turn = snap.val() || null;
    renderMyRole();
    requestRenderPlayerCircle();
  });
  onValue(pRef, snap => {
    const v = snap.val() || {};
    state.placedDrops = {
      player: v.player || {},
      center: v.center || {}
    };
    requestRenderPlayerCircle();

    hostStartChallengeIfNeeded();
  });
}
function subscribeAttackDeck(){
  const aRef = ref(db, `rooms/${state.roomCode}/attackDeck`);
  onValue(aRef, snap => {
    state.attackDeck = snap.val() || null;
    renderChallengeUI();
  });
}

/* ★post処理（クライアント側） */
let lastChallengePostKey = '';
function applyJustRevealedToTarget(target){
  try{
    if (!target) return;
    if (target.kind === 'center'){
      ajitoCenterEl.classList.add('just-revealed');
      setTimeout(()=>ajitoCenterEl.classList.remove('just-revealed'), 650);
    } else if (target.kind === 'player'){
      const el = playerCircle.querySelector(`.ajito-card[data-ajito-owner="${target.id}"]`);
      if (!el) return;
      el.classList.add('just-revealed');
      setTimeout(()=>el.classList.remove('just-revealed'), 650);
    }
  } catch {}
}
async function handleChallengePost(ch){
  if (!ch?.active) { lastChallengePostKey = ''; return; }
  const seq = ch.postSeq || 0;
  const key = `${ch.startedAt || ''}:${seq}`;
  if (key === lastChallengePostKey) return;
  lastChallengePostKey = key;

  const post = ch.post || null;
  if (!post || !post.type) return;

  if (post.type === 'revealAjito'){
    applyJustRevealedToTarget(post.target);
  }

  if (post.type === 'focusAjito'){
    const t = post.ajitoType;
    if (!t) return;
    showAjitoFocus(t, post.isBoom ? 'boom' : 'zoom');
  }

  if (post.type === 'redealAjito'){
    const src = Array.isArray(post.sourceSlots) ? post.sourceSlots : [];
    const dst = Array.isArray(post.destSlots) ? post.destSlots : src.slice();
    await runAjitoRedealAnim(src, dst);
  }

  // ★追加：全員正体公開 post（表示自体は room.rolesOpen で切替）
  if (post.type === 'revealRoles'){
    requestRenderPlayerCircle();
    renderMyRole();
    if (!helpBackdrop.classList.contains('hidden')) renderHelpList();
  }
}

function subscribeChallenge(){
  const cRef = ref(db, `rooms/${state.roomCode}/challenge`);
  onValue(cRef, snap => {
    state.challenge = snap.val() || null;

    renderMyRole();
    requestRenderPlayerCircle();
    renderChallengeUI();

    handleChallengePost(state.challenge);

    hostProgressChallenge();
  });
}

/* ====== 表示 ====== */
function roleTypeToImg(type){
  return (type === 'tero') ? IMG.role_tero : IMG.role_swat;
}
function renderMyRole(){
  myHandEl.innerHTML = '';
  const my = state.roles[state.userId];
  if (!my || !my.type) return;

  const card = document.createElement('div');
  card.className = 'my-role-card';
  card.style.backgroundImage = `url('${roleTypeToImg(my.type)}')`;
  myHandEl.appendChild(card);

  const myColor = makeColorCardEl(state.userId, 'my-right');
  if (isMyTurn()){
    myColor.classList.add('turn-pulse');
    markDraggable(myColor);
  }
  myHandEl.appendChild(myColor);

  const ch = state.challenge;
  if (ch?.active && ch.stage === 'select' && !ch.uiClosed){
    const myNeed = getChallengeMyNeed(ch);
    if (myNeed > 0){
      const dealt = getChallengeMyDealt(ch);
      const chosenIds = new Set(getChallengeMyChosen(ch));
      const decided = isChallengeMyDecided(ch);

      dealt
        .filter(c => !chosenIds.has(c.id))
        .forEach((c) => {
          const a = makeAttackCardEl(c, true, '');
          if (!decided){
            a.classList.add('turn-pulse');
            a.classList.add('draggable');
            a.addEventListener('pointerdown', (e) => startAttackDrag(e, a, 'hand'));
          }
          myHandEl.appendChild(a);
        });
    }
  }
}

/* ====== 入室 ====== */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeRoles();
  subscribeAjito();
  subscribeTurnAndPlaced();
  subscribeAttackDeck();
  subscribeChallenge();

  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

/* ====== 着席 ====== */
async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;
  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    rebuildColorMap(players);

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    requestRenderPlayerCircle();
    renderMyRole();
    if (!helpBackdrop.classList.contains('hidden')) renderHelpList();
  });
}

/* =========================
   ★chiparea基準の「溜まり山」
   ========================= */
function ensurePileHolder(parentEl, className){
  let h = parentEl.querySelector(`.${className}`);
  if (!h){
    h = document.createElement('div');
    h.className = `pile-holder ${className}`;
    parentEl.appendChild(h);
  } else {
    h.innerHTML = '';
  }
  h.style.setProperty('--pile-x', '22px');
  h.style.setProperty('--pile-y', '-28px');
  return h;
}

function renderDropsIntoHolder(holder, drops){
  const GAP_Y = 12;
  const FIX_X = 0;

  drops.forEach((d, i) => {
    const fromId = d.from;
    if (!fromId) return;
    const pc = makeColorCardEl(fromId, 'placed-color');
    pc.style.setProperty('--pc-x', `${FIX_X}px`);
    pc.style.setProperty('--pc-y', `${i * GAP_Y}px`);
    holder.appendChild(pc);
  });
}

/* ===== ★ 3時/9時判定（角度からpos-3 / pos-9 を付与） ===== */
function normDeg(deg){
  let d = deg % 360;
  if (d < 0) d += 360;
  return d;
}
function degDiff(a, b){
  const d = Math.abs(normDeg(a) - normDeg(b));
  return Math.min(d, 360 - d);
}
function getClockPosClass(angleRad){
  const deg = normDeg(angleRad * 180 / Math.PI);
  if (degDiff(deg, 0) < 18) return 'pos-3';
  if (degDiff(deg, 180) < 18) return 'pos-9';
  return '';
}

function renderPlayerCircle(players){
  playerCircle.querySelectorAll('.player-tag, .center-placed, .pile-holder.center-pile').forEach(el => el.remove());
  if (!players.length) return;

  ajitoCenterEl.classList.toggle('hidden', !state.ajitoCenter);
  ajitoCenterChipEl.classList.toggle('hidden', !state.ajitoCenter);

  const showDeck = !!(state.ajitoCenter && state.attackDeck && Array.isArray(state.attackDeck.draw));
  attackDeckEl.classList.toggle('hidden', !showDeck);
  if (showDeck){
    attackDeckCountEl.textContent = String(state.attackDeck.draw.length || 0);
  }

  if (state.ajitoCenter && state.ajitoCenter.type){
    const isRev = !!state.ajitoCenter.revealed;
    ajitoCenterEl.style.backgroundImage = `url('${isRev ? ajitoTypeToImg(state.ajitoCenter.type) : IMG.ajito_back}')`;
  }

  const n = players.length;

  const radius = 58;
  const distOuter = 40;
  const distAj = 50;

  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  const activeId = isChallengeActive() ? null : (state.turn?.activePlayerId || null);

  const rolesOpen = !!state.room?.rolesOpen;

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top = `${y}%`;

    const posClass = getClockPosClass(angle);
    if (posClass) tag.classList.add(posClass);

    if (p.id !== state.userId){
      const wrap = document.createElement('div');
      wrap.className = 'tag-color-wrap';

      const mini = makeColorCardEl(p.id, '');
      if (activeId && p.id === activeId){
        mini.classList.add('turn-pulse');
      }
      wrap.appendChild(mini);
      tag.appendChild(wrap);
    }

    tag.onclick = () => {
      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    const ox = Math.cos(angle);
    const oy = Math.sin(angle);
    const ix = -ox;
    const iy = -oy;

    // ★ここを変更：rolesOpen のときは「表」を表示
    if (p.id !== state.userId && state.roles[p.id]?.type){
      const rType = state.roles[p.id].type;

      if (rolesOpen){
        const miniFront = document.createElement('div');
        miniFront.className = 'role-front-mini';
        miniFront.style.setProperty('--rb-x', `${ox * distOuter}px`);
        miniFront.style.setProperty('--rb-y', `${oy * distOuter}px`);
        miniFront.style.backgroundImage = `url('${roleTypeToImg(rType)}')`;
        tag.appendChild(miniFront);
      } else {
        const miniBack = document.createElement('div');
        miniBack.className = 'role-back-mini';
        miniBack.style.setProperty('--rb-x', `${ox * distOuter}px`);
        miniBack.style.setProperty('--rb-y', `${oy * distOuter}px`);
        tag.appendChild(miniBack);
      }
    }

    if (state.ajito[p.id]?.type){
      const chip = document.createElement('div');
      chip.className = 'chiparea';
      chip.dataset.chipOwner = p.id;

      const tx = ix * distAj;
      const ty = iy * distAj;

      chip.style.setProperty('--chip-x', `${tx}px`);
      chip.style.setProperty('--chip-y', `${ty}px`);
      tag.appendChild(chip);

      const aj = document.createElement('div');
      aj.className = 'ajito-card' + (p.id === state.userId ? ' mine' : '');
      aj.dataset.ajitoOwner = p.id;

      const angleDeg = angle * 180 / Math.PI;
      const rotDeg = angleDeg + 270;

      aj.style.setProperty('--ajito-x', `${tx}px`);
      aj.style.setProperty('--ajito-y', `${ty}px`);
      aj.style.setProperty('--ajito-rot', `${rotDeg}deg`);

      const isRev = !!state.ajito[p.id]?.revealed;
      aj.style.backgroundImage = `url('${isRev ? ajitoTypeToImg(state.ajito[p.id].type) : IMG.ajito_back}')`;

      if (p.id === state.userId){
        aj.addEventListener('click', (e) => {
          e.stopPropagation();
          const myAj = state.ajito[state.userId];
          if (!myAj?.type) return;
          openAjitoPeek(myAj.type);
        });
      }
      tag.appendChild(aj);

      const obj = state.placedDrops?.player?.[p.id] || {};
      const drops = Object.values(obj)
        .filter(Boolean)
        .sort((a,b) => (a.at||0) - (b.at||0));

      if (drops.length){
        const holder = ensurePileHolder(tag, 'player-pile');
        holder.style.transform =
          `translate(-50%,-50%) translate(${tx}px, ${ty}px) translate(var(--pile-x,22px), var(--pile-y,-10px))`;
        renderDropsIntoHolder(holder, drops);
      }
    }

    playerCircle.appendChild(tag);
  });

  const centerObj = state.placedDrops?.center || {};
  const centerDrops = Object.values(centerObj)
    .filter(Boolean)
    .sort((a,b) => (a.at||0) - (b.at||0));

  if (centerDrops.length && state.ajitoCenter){
    const holder = document.createElement('div');
    holder.className = 'pile-holder center-pile center-placed';
    holder.style.setProperty('--pile-x', '22px');
    holder.style.setProperty('--pile-y', '-28px');
    playerCircle.appendChild(holder);
    renderDropsIntoHolder(holder, centerDrops);
  }
}

/* ====== 追い出し ====== */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* ====== 配布 ====== */
function getTeroCount(n){
  if (n <= 3) return 0;
  if (n === 4) return (Math.random() < 0.5) ? 1 : 2;
  if (n === 5) return 2;
  if (n === 6) return (Math.random() < 0.5) ? 2 : 3;
  return Math.max(0, Math.floor(n/3));
}
function buildAjitoDeck(n){
  const deck = [];
  const pushN = (type, count) => { for(let i=0;i<count;i++) deck.push(type); };

  if (n === 1){
    pushN('hideout', 2);
  } else if (n === 2){
    pushN('hideout', 2); pushN('boom', 1);
  } else if (n === 3){
    pushN('hideout', 2); pushN('boom', 1); pushN('dummy', 1);
  } else if (n === 4){
    pushN('hideout', 2); pushN('dummy', 2); pushN('boom', 1);
  } else if (n === 5){
    pushN('hideout', 2); pushN('dummy', 3); pushN('boom', 1);
  } else if (n === 6){
    pushN('hideout', 3); pushN('dummy', 3); pushN('boom', 1);
  } else {
    pushN('hideout', Math.max(2, Math.ceil((n+1)/2)));
    pushN('dummy', Math.max(0, (n+1) - deck.length - 1));
    pushN('boom', 1);
  }
  return deck;
}

async function dealRolesAndAjito(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const players = Object.values(tables)
    .filter(t => t && t.playerId)
    .map(t => ({ id: t.playerId, name: t.playerName || '名無し' }));

  const n = players.length;
  if (n <= 0) return;

  const teroCount = getTeroCount(n);
  const rolesArr = [];
  for (let i=0;i<teroCount;i++) rolesArr.push('tero');
  for (let i=0;i<n-teroCount;i++) rolesArr.push('swat');
  shuffle(rolesArr);

  const rolesObj = {};
  players.forEach((p, i) => {
    rolesObj[p.id] = { type: rolesArr[i] };
  });

  const deck = buildAjitoDeck(n);
  shuffle(deck);

  const centerType = deck.pop();
  const ajObj = {};
  players.forEach((p) => {
    ajObj[p.id] = { type: deck.pop(), revealed:false };
  });

  const startPlayerId = players[Math.floor(Math.random() * players.length)].id;

  const attack = {
    draw: buildAttackDeck(n),
    discard: []
  };

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    set(ref(db, `${base}/roles`), rolesObj),
    set(ref(db, `${base}/ajito`), ajObj),
    set(ref(db, `${base}/ajitoCenter`), { type: centerType, revealed:false }),
    set(ref(db, `${base}/attackDeck`), attack),

    // ★追加：新ゲーム開始時は正体公開フラグを戻す
    update(ref(db, `${base}`), {
      gameStartedAt: Date.now(),
      rolesOpen: false,
      rolesOpenAt: null,
      rolesOpenReason: null
    }),

    remove(ref(db, `${base}/placedDrops`)),
    remove(ref(db, `${base}/challenge`)),
    set(ref(db, `${base}/turn`), {
      activePlayerId: startPlayerId,
      turnNo: 1,
      startedAt: Date.now()
    }),
  ]);
}

/* ====== ホスト設定ポップ ====== */
hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});
btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await dealRolesAndAjito();
  startPop.classList.add('hidden');
});

/* ====== リセット ====== */
btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;

  await Promise.all([
    remove(ref(db, `${base}/roles`)),
    remove(ref(db, `${base}/ajito`)),
    remove(ref(db, `${base}/ajitoCenter`)),
    remove(ref(db, `${base}/attackDeck`)),
    remove(ref(db, `${base}/challenge`)),
    remove(ref(db, `${base}/gameStartedAt`)),
    remove(ref(db, `${base}/turn`)),
    remove(ref(db, `${base}/placedDrops`)),
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),

    // ★追加：正体公開フラグも消す
    remove(ref(db, `${base}/rolesOpen`)),
    remove(ref(db, `${base}/rolesOpenAt`)),
    remove(ref(db, `${base}/rolesOpenReason`)),
  ]);

  state.seatedTable = null;

  startPop.classList.add('hidden');
  await syncSeatUI();
});
</script>

</body>
</html>
